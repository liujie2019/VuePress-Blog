---
title: 5. ES6基础知识点汇总
---
### var、let及const区别

- var声明的变量可以修改，如果不初始化会输出undefined，不会报错，其作用域为该语句所在的函数内，且存在变量提升现象；
- let声明的变量，其作用域为该语句所在的代码块内(块级作用域，函数内部使用let定义后，对函数外部无影响)，不存在变量提升；
- let不允许重复声明；
- const定义的变量不可以修改(用来声明常量)，而且必须初始化

### 原型继承和Class继承

主要涉及：原型如何实现继承？Class如何实现继承？ES5继承与ES6继承的区别？Class 本质是什么？

1. ES5的继承，实质是先创造子类的实例对象this，然后再将父类的方法添加到this上面(Parent.apply(this))。ES6的继承机制完全不同，实质是先将父类实例对象的属性和方法，加到this上面(所以必须先调用super方法)，然后再用子类的构造函数修改this。
```js
class Person {}
console.log(Person instanceof Function); // true
```
### 前端模块化

主要涉及：为什么要使用模块化？前端实现模块化的方式有哪几种，各有什么特点？
使用一个技术肯定是有原因的，那么使用模块化可以给我们带来以下好处

1. 解决命名冲突；
2. 提高代码复用性；
3. 提高代码可维护性。

#### CommonJS 中的 require/exports 和 ES6 中的 import/export 区别？

- 1. CommonJS 模块的重要特性是加载时执行，即脚本代码在 require 的时候，就会全部执行。一旦出现某个模块被”循环加载”，就只输出已经执行的部分，还未执行的部分不会输出。
- 2. ES6 模块是动态引用，如果使用 import 从一个模块加载变量，那些变量不会被缓存，而是成为一个指向被加载模块的引用，需要开发者自己保证，真正取值的时候能够取到值。
- 3. import/export 最终都是编译为 require/exports 来执行的。
- 4. CommonJS 规范规定，每个模块内部，module 变量代表当前模块。这个变量是一个对象，它的 exports 属性（即 module.exports ）是对外的接口。加载某个模块，其实是加载该模块的 module.exports 属性。
- 5. export 命令规定的是对外的接口，必须与模块内部的变量建立一一对应关系。

### Proxy

主要涉及：Proxy可以实现什么功能？相比于Object.defineProperty的优势在哪里？

### 箭头函数与普通函数的区别是什么？

主要涉及：构造函数可以使用new生成实例，那么箭头函数可以吗？为什么？
箭头函数是普通函数的简写，可以更优雅的定义一个函数，和普通函数相比，有以下几点差异：
1. 函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象。
2. 不可以使用arguments对象，该对象在函数体内不存在。如果要用，可以用rest参数代替。
3. 不可以使用yield命令，因此箭头函数不能用作 Generator 函数。
4. 不可以使用new命令，因为：
   * 没有自己的this，无法调用call，apply。
   * 没有prototype属性 ，而 new 命令在执行时需要将构造函数的 prototype 赋值给新的对象的__proto__。

主要区别在this指向问题：
1. 普通函数的this 指向调用它的那个对象，例如 obj.func，那么func中的this就是obj；
2. 箭头函数不能作为构造函数，不能使用new，没有this，arguments箭头函数，箭头函数的this永远指向其上下文的this，任何方法都改变不了其指向，如 call/bind/apply(或者说箭头函数中的this指向的是定义时的this，而不是执行时的this)。

```js
var name = "The Window";
var object = {
　　　　name : "My Object",
　　　　getNameFunc : function(){
            console.log(this.name); // My Object
    　　　　　return function(){
    　　　　　　　return this.name; // The Window
    　　　　  };
　　　　},
　　　　b: () => {
           return this.name; // the window
       },
       c() {
           return () => {
              return this.name; // My Object
          }
       }
}
```
new过程大致是这样的：
```js
function newFunc(father, ...rest) {
  var result = {};
  result.__proto__ = father.prototype;
  var result2 = father.apply(result, rest);
  if (
    (typeof result2 === 'object' || typeof result2 === 'function') &&
    result2 !== null
  ) {
    return result2;
  }
  return result;
}
```
### Set、Map、WeakSet和WeakMap的区别？

Map和Set的区别：
* Set对象类似于数组，且成员的值都是唯一的。
* Map对象是键值对集合，和JSON对象类似，但是key不仅可以是字符串还可以是对象。

WeakMap和Map的区别:

WeakMap结构与Map结构基本类似，唯一的区别是：WeakMap只接受对象作为键名（null除外），不接受其他类型的值作为键名，而且键名所指向的对象，**不计入垃圾回收机制**。
WeakMap最大的好处是：可以避免内存泄漏。一个仅被WeakMap作为key而引用的对象，会被垃圾回收器回收掉。

WeakMap拥有和Map类似的`set(key, value) 、get(key)、has(key)、delete(key) 和 clear()` 方法，没有任何与迭代有关的属性和方法。

### Promise 的理解

Promise 对象代表一个异步操作，有三种状态：`Pending（进行中）`、`Resolved（已完成，又称Fulfilled）`和`Rejected（已失败）`。