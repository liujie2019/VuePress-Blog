---
title: 4. JS手写代码
---
[TOC]
## 1. Object.create实现
Object.create(obj)基本原理：接收一个obj对象，然后创建一个空对象，让空对象的`__proto__`指向obj，最终返回这个空对象。
实现思路：
1. 接收一个要作为原型的对象；
2. 返回一个原型指向该对象的空对象
```js
Object.create = function(obj) {
    let o = {};
    // 理论上是可以的，但是__proto__在ie中不支持
    o.__proto__ = obj;
    return o;
}
```
Object.create()方法创建一个新对象，使用现有的对象来提供新创建的对象的__proto__。
```js
// 模拟Object.create
Object.create = function(proto) {
    function Fn() {};
    Fn.prototype = proto;
    // new Fn()就是一个空对象，因为没有任何私有属性和方法
    return new Fn();
}
```
## 2. new操作符实现
new操作符做了什么：
1. 创建了一个全新的对象。
2. 这个对象会被执行`[[Prototype]]`(也就是`__proto__`)链接。
3. 使得this指向新创建的对象。
4. 通过new创建的每个对象将最终被`[[Prototype]]`链接到这个函数的prototype对象上。
5. 如果函数没有返回对象类型Object(包含Functoin，Array，Date，RegExg，Error)，那么new表达式中的函数调用会自动返回这个新的对象。
```js
function myNewOperator() {
    if (typeof ctor !== 'function') {
        throw new Error('newOperator function the first param must be a function');
    }
    // new.target是指向构造函数的
    myNewOperator.target = ctor;
    // 新建一个对象，并指向构造函数原型
    var newObj = Object.create(ctor.prototype);
    var argsArr = Array.prototype.slice.call(arguments, 1);
    // 获取构造函数的结果
    var ctorRes = ctor.apply(newObj, argsArr);
    // 判断构造函数结果是否为函数或者对象类型
    var isObject = typeof ctorRes === 'object' && ctorRes !== null;
    var isFunction = typeof ctorRes === 'function';
    // 为函数或者对象类型，直接返回该结果
    if (isObject || isFunction) {
        return ctorRes;
    }
    // 否则返回新建的实例对象
    return newObj;
}
```
```js
// objectFactory(name,'cxk','18')
function objectFactory(){
    const obj = new object();
    const Constructor = [].shift.call(arguments);

    obj.__proto__ = Constructor.prototype;

    const ret = Constructor.apply(obj,arguments);

    return typeof ret === "object" ? ret : obj;
}
```
## 3. 观察者模式实现
```js
class Subject {
    constructor(name) {
        this.name = name;
        this.observers = []; // 存放观察者
        this.state = '心情很美丽';
    }
    // 被观察者添加观察者的方法(观察者和被观察者建立关系)
    attach(observer) {
        this.observers.push(observer);
    }
    // 更改被观察者的状态
    setState(newState) {
        this.state = newState;
        this.notify(); // 被观察者状态发生变化时，通知观察者
    }
    notify() {
        this.observers.forEach(o => {
            o.update(this.state);
        });
    }
}

class Observer {
    constructor(name) {
        this.name = name;
    }
    update(newState) {
        console.log(`${this.name}说：小公主${newState}`);
    }
}
// 创建一个被观察者
const sub = new Subject('小公主');
// 创建两个观察者
const o1 = new Observer('爸爸');
const o2 = new Observer('妈妈');
// 被观察者添加观察者
sub.attach(o1);
sub.attach(o2);
// 被观察者更新状态，并通知观察者
sub.setState('不开心了');
```
Vue的依赖收集就是基于观察者模式(基于watcher)。观察者模式包含发布订阅模式。
## 4. 发布订阅模式实现
```js

```
### 实现Event (event bus)
event bus既是node中各个模块的基石，又是前端组件通信的依赖手段之一，同时涉及了订阅-发布设计模式，是非常重要的基础。
简单版：
```js
class EventEmeitter {
    constructor(){
        this._events = this._events || new Map(); //储存事件/回调键值对
        this._maxListeners = this._maxListeners || 1o;//设立监听上限
    }
}

//触发名为type的事件
EventEmeitter.prototype.emit = function(type,...args){
    let hander;
    //从储存事件键值对的this._events中获取对应事件回调函数
    handler = this._events.get(type);
    if (args.length > 0) {
        hander.apply(this,args);
    }else{
        handler.call(this);
    }
    return true;
};

//监听名为type事件
EventEmeitter.prototype.addListener = function(type,fn) {
    //将type事件以及对应的fn函数放入this._events中储存
    if (!this._events.get(type)) {
        this._events.set(type,fn);
    }
};
```
## 5. 实现一个sleep函数
```js
function sleep(ms) {
    return new Promise((resolve, reject) => {
        setTimeout(resolve, ms);
    });
}
```
## 6. 判断是否为Promise对象
```js
function isPromise(p) {
  return p && typeof p.then === 'function' && typeof p.catch === 'function';
}
// 判断是否是Generator对象
function isGenerator(obj) {
  return obj && 'function' === typeof obj.next && 'function' === typeof obj.throw;
}
```
## 7. 实现(5).add(3).minus(2),使其输出结果为6
```js
/**
 * 实现(5).add(3).minus(2),使其输出结果为6
*/
// 实现一个闭包
~function() {
    // 每一个方法执行完，都要返回Number这个类的实例，这样才可以继续调用Number类原型中的方法(链式操作)
    function checkNum(n) {
        n = Number(n);
        return isNaN(n) ? 0 : n;
    }
    function add(n) {
        return this + n;
    }
    function minus(n) {
        return this - n;
    }
    ['add', 'minus'].forEach(method => {
        Number.prototype[method] = eval(method);
    });
}();

console.log((5).add(3).minus(2)); // 6
```
## 8. 数据类型判断函数实现
```js
Object.prototype.toString.call()
```
## 9. 实现简单的数组求和
```js
eval([1, 2,3 ].join('+'))
// 或者
arr.reduce();
```
## 10. 实现简单的数组去重
基础数据结构数组：
```js
[...new Set([...])]或Array.from(new Set(array))(set返回的结构不是数组类型)
```
对象数组类型数组：
```js
// 方法：
//定义常量res，值为一个Map对象实例
const res = new Map();
//返回arr数组过滤后的结果，结果为一个数组
//过滤条件是，如果res中没有某个键，就设置这个键的值为1
return arr.filter((a) => !res.has(a) && res.set(a, 1))
// 方法2：利用reduce方法遍历数组，reduce第一个参数是遍历需要执行的函数，第二个参数是item的初始值
var obj = {};
arr = arr.reduce((item, next) => {
   obj[next.key] ? '' : obj[next.key] = true && item.push(next);
    return item;
 }, []);
```
## 11. 求数组交集/并集/差集
①直接使用filter、concat来计算
```js
var a = [1,2,3,4,5]
var b = [2,4,6,8,10]
//交集
var c = a.filter(function(v){ return b.indexOf(v) > -1 })
//差集
var d = a.filter(function(v){ return b.indexOf(v) == -1 })
//补集
var e = a.filter(function(v){ return !(b.indexOf(v) > -1) })
.concat(b.filter(function(v){ return !(a.indexOf(v) > -1)}))
//并集
var f = a.concat(b.filter(function(v){ return !(a.indexOf(v) > -1)}));
console.log("数组a：", a);
console.log("数组b：", b);
console.log("a与b的交集：", c);
console.log("a与b的差集：", d);
console.log("a与b的补集：", e);
console.log("a与b的并集：", f);
```
② 借助扩展运算符（...）以及 Set 的特性实现相关计算，代码也会更加简单些
```js
var a = [1,2,3,4,5]
var b = [2,4,6,8,10]
console.log("数组a：", a);
console.log("数组b：", b);
var sa = new Set(a);
var sb = new Set(b);
// 交集
let intersect = a.filter(x => sb.has(x));
// 差集
let minus = a.filter(x => !sb.has(x));
// 补集
let complement = [...a.filter(x => !sb.has(x)), ...b.filter(x => !sa.has(x))];
// 并集
let unionSet = Array.from(new Set([...a, ...b]));
console.log("a与b的交集：", intersect);
console.log("a与b的差集：", minus);
console.log("a与b的补集：", complement);
console.log("a与b的并集：", unionSet);
```
## 12. 实现防抖函数(debounce)和节流函数(throttle)
### 防抖函数(debounce)
防抖函数原理：在事件被触发n秒后再执行回调，如果在这n秒内又被触发，则重新计时。
```js
//防抖函数
const debounce = (fn, delay) => {
    let timer = null;
    return (...args) => {
        clearTimeout(timer);
        timer = setTimeout(() => {
            fn.apply(this,args);
        }, delay);
    };
};
```
适用场景 ：
* 按钮提交场景： 防止多次提交按钮，只执行最后提交的一次；
* 服务端验证场景 ： 表单验证需要服务端配合，只执行一段连续的输入事件的最后一次，还有搜索联想词功能类似

生存环境请用lodash.debounce
### 节流函数(throttle)
节流函数原理：规定在一单位时间内。只能触发一次函数。如果这个单位时间内触发多次函数，只有一次生效。
```js
//节流函数
const throttle = (fn,delay = 500) =>{
    let flag = true;
    return (...args) =>{
        if (!flag) return;
        flag = false;
        setTimeout(() => {
        fn.apply(this,args)
        },delay);
    };
};
```
适用场景：
* 拖拽场景：固定时间内只执行一次，防止超高频次触发位置变动
* 缩放场景：监控浏览器resize
* 动画场景：避免短时间内多次触发动画引起性能问题
## 13. 深克隆 (deepclone)
简单版：
```js
const newObj = JSON.parse(JSON.stringify(oldObj));
```
局限性 ：
1. 无法实现函数、RegExp等特殊对象的克隆
2. 会抛弃对象的constructor，所有的构造函数会指向Object
3. 对象有循环引用，会报错
## 14. 实现instanceOf
```js
//模拟 instanceof
function instance_of(L,R){
    var O = R.prototype;//取 R 的显示原型
    L = L.__proto__;//取 L 的隐式原型
    while (true) {
        if (L === null) return false;
        if (O === L)
        // 这里重点 ： 当 O 严格等于 L 时，返回 true
        return true;
        L = L.__proto__;
    }
}
```
## 15. 实现call/apply/bind
### call
call做了什么 ：
* 将函数设为对象的属性
* 执行&删除这个函数
* 指定this到函数并传人给定参数执行函数
* 如果不传入参数，默认指向为window
```js
//模拟 call bar.mycall(null);
//实现一个call方法；
Function.prototype.myCall = function(context){
    //此处没有考虑context非object情况
    context.fn = this;
    let args = [];
    for (let i = 1,len = arguments.length,i < len; i++){
        args.push(arguments[i]);
    }
    context.fn(...args);
    let result = context.fn(...args);
    delete context.fn;
    return result;
};
```
### apply
```js
//模拟 apply
Function.prototype.myapply = function(context,arr){
    var context = Object(context) || window;
    context.fn = this;

    var result;
    if (!arr){
        result = context.fn();
    }else{
        var args = [];
        for (var i = 0,len = arr.length;i < len; i++){
            args.push("arr["+ i +"]");
        }
        result = eval("context.fn("+ args + ")");
    }
    delete context.fn;
    return result;
}
```
### bind
实现bind要做什么？
* 返回一个函数，绑定this，传递预置参数
* bind返回的函数可以作为构造函数使用。故作为构造函数时应使得this失效，但是传人的参数依然有效
```js
// mdn的实现
if (!Function.prototype.bind) {
  Function.prototype.bind = function(oThis) {
    if (typeof this !== 'function') {
      // closest thing possible to the ECMAScript 5
      // internal IsCallable function
      throw new TypeError('Function.prototype.bind - what is trying to be bound is not callable');
    }

    var aArgs   = Array.prototype.slice.call(arguments, 1),
        fToBind = this,
        fNOP    = function() {},
        fBound  = function() {
          // this instanceof fBound === true时,说明返回的fBound被当做new的构造函数调用
          return fToBind.apply(this instanceof fBound
                 ? this
                 : oThis,
                 // 获取调用时(fBound)的传参.bind 返回的函数入参往往是这么传递的
                 aArgs.concat(Array.prototype.slice.call(arguments)));
        };

    // 维护原型关系
    if (this.prototype) {
    }
    // 下行的代码使fBound.prototype是fNOP的实例,因此
    // 返回的fBound若作为new的构造函数,new生成的新对象作为this传入fBound,新对象的__proto__就是fNOP的实例
    fBound.prototype = new fNOP();

    return fBound;
  };
}

// 详解请移步JavaScript深入之bind的模拟实现 #12
```
## 16. 解析URL Params为对象
```js
let url = 'http://www.domain.com/?user=anonymous&id=123&id=456&city=%E5%8C%97%E4%BA%AC&enabled';
parseParam(url)

/* 结果
{ user: 'anonymous',
  id: [ 123, 456 ], // 重复出现的 key 要组装成数组，能被转成数字的就转成数字类型
  city: '北京', // 中文需解码
  enabled: true, // 未指定值得 key 约定为 true
}
*/
```
## 17. 转化为驼峰命名
```js
var s1 = "get-element-by-id"
// 转化为 getElementById
var f = function(s){
    return s.replace(/-\w/g,function(x){
      return x.slice(1).toUpperCase();
    })
}
```