---
title: 2. CSS基础知识总结
---
[TOC]
## 1. 列举常见CSS选择器，哪些属性可以继承？选择器优先级如何计算？
CSS选择器类型：
* ID选择器：#
* 类选择器(class)：.box
* 标签：div
* 相邻：ul+div(选中ul后面紧邻的div)
* 相邻：ul~div(选中ul后面所有的div)
* 子选择器：ul>li
* 后代选择器：ul li
* 分组选择器：div,p
* 属性选择器：a[href='xxx']
* 伪类选择器：a:hover
* 伪元素选择器：div::after(一个冒号也好使)
* 通配符：`*`
### 伪类选择器和伪元素选择器的区别
* 伪类选择器：a:hover，并不是真正存在的一个css类，而是鼠标浮上去的时候添加对应的css样式。
* 伪元素选择器：div::after，相当于在div标签的最后添加一个不真实存在的元素，所以称为伪元素。
### 选择器优先级
!important > 行内样式 > id > 类 > 标签。

权重计算规则：
* 第一级别：内联样式，如style=""，权重为1000
* 第二级别：id选择器，权重为0100
* 第三级别：类、伪类和属性选择器，权重为0010
* 第四级别：标签选择器和伪元素选择器，权重为0001
* 通配符、子选择器、相邻选择器等的。如*、>、+，权重为0000
* 继承的样式没有权值
虽然权重值是累加的，但是11个类选择器权重值为110，但是也没有一个id选择器(权重值为100)优先级高。
### CSS可继承属性
* color
* font-size
## 2. 介绍一下盒模型
CSS盒模型本质上是一个盒子，封装周围的HTML元素，它包括：边距margin，边框border，填充padding，和实际内容content。盒模型允许我们在其它元素和周围元素边框之间的空间放置元素。
<img :src="$withBase('/interview/box.png')" alt="">

box-sizing: content-box（W3C盒模型，又名标准盒模型）：元素的宽高大小表现为内容的大小。 box-sizing: border-box（IE盒模型，又名怪异盒模型）：元素的宽高表现为内容 + 内边距 + 边框的大小。背景会延伸到边框的外沿。

①盒模型：内容(content)、填充(padding)、边界(margin)、边框(border)
②类型：IE 盒子模型、标准 W3C 盒子模型；
③两种盒模型的主要区别是:标准盒模型的宽高是值内容宽高(content)
④而IE盒模型的宽高是指content+padding+border。
⑤设置盒模型的方式是：设置box-sizing box-sizing:content-box  标准盒模型， box-sizing:border-box IE盒模型

包括：margin->border->padding->content。
* 标准模型：宽高计算不包含padding和border；通过 `box-sizing: content-box;`来设置（浏览器默认）。
* IE模型：宽高计算包含 padding 和 border ;通过 box-sizing: border-box; 来设置。
## 3. BFC(块状格式化上下文)
BFC（Block Formatting Context）格式化上下文，是Web页面中盒模型布局的CSS渲染模式，指一个独立的渲染区域或者说是一个隔离的独立容器。 

BFC应用
* 防止margin重叠
* 清除内部浮动
* 自适应两（多）栏布局
* 防止字体环绕

触发BFC条件
* 根元素
* float的值不为none
* overflow的值不为visible
* display的值为inline-block、table-cell、table-caption
* position的值为absolute、fixed

BFC的特性
* 内部的Box会在垂直方向上一个接一个的放置。
* 垂直方向上的距离由margin决定
* bfc的区域不会与float的元素区域重叠。
* 计算bfc的高度时，浮动元素也参与计算
* bfc就是页面上的一个独立容器，容器里面的子元素不会影响外面元素。

特点：
* 是一个独立的容器，里面的元素和外面的元素互不影响；
* BFC垂直方向的margin会发生重叠；
* BFC区域不会与浮动元素区域重叠；
* 计算BFC高度时，浮动元素也参与计算。

触发方式：
* float值不为none;
* position的值不为static或relative;
* display为inline-block, table, table-cell 等；
* overflow不为visible。

作用：
* 清除浮动
* 防止同一BFC容器中的相邻元素间的外边距重叠问题
## 4. 实现水平居中/垂直居中/垂直水平居中布局
### div水平居中
行内元素：
```css
.parent {
    text-align: center;
}
```
块级元素
```css
.son {
    margin: 0 auto;
}
```
flex布局
```css
.parent {
    display: flex;
    justify-content: center;
}
```
绝对定位定宽
```css
.son {
    position: absolute;
    width: 宽度;
    left: 50%;
    margin-left: -0.5*宽度
}
```
绝对定位不定宽
```css
.son {
    position: absolute;
    left: 50%;
    transform: translate(-50%, 0);
}
```
left/right: 0
```css
.son {
    position: absolute;
    width: 宽度;
    left: 0;
    right: 0;
    margin: 0 auto;
}
```
### 垂直居中
行内元素
```css
.parent {
    height: 高度;
}
.son {
    line-height: 高度;
}
```
table
```css
.parent {
  display: table;
}
.son {
  display: table-cell;
  vertical-align: middle;
}
```
flex
```css
.parent {
    display: flex;
    align-items: center;
}
```
绝对定位定高
```css
.son {
    position: absolute;
    top: 50%;
    height: 高度;
    margin-top: -0.5高度;
}
```
绝对定位不定高
```css
.son {
    position: absolute;
    top: 50%;
    transform: translate( 0, -50%);
}
```
top/bottom: 0;
```css
.son {
    position: absolute;
    height: 高度;
    top: 0;
    bottom: 0;
    margin: auto 0;
}
```
### 垂直水平居中
#### 宽高固定
```css
div.parent {
    position: relative;
}
div.child {
    width: 100px;
    height: 200px;
    position: absolute;
    top: 50%;
    left: 50%;
    margin-left: -50px;
    margin-top: -100px;
}
```
绝对定位水平垂直居中
```css
div.parent {
    position: relative;
}
div.child {
    width: 100px;
    height: 100px;
    position: absolute;
    left: 0;
    top: 0;
    right: 0;
    bottom: 0;
    margin: auto;
    background-color: green;
}
```
#### 宽高不固定
flex布局居中
```css
div.parent {
    display: flex;
    justify-content: center;
    align-items: center;
}
```
```css
div.parent{
  display: flex;
}
div.child{
  margin: auto;
}
```
```css
div.parent {
    position: relative;
}
div.child {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
}
```
网格布局居中
```css
div.parent {
    display: grid;
}
div.child {
    justify-self: center;
    align-self: center;
}
```
更多[干货!各种常见布局实现+知名网站实例分析](https://juejin.im/post/5aa252ac518825558001d5de)

## 5. 分析比较隐藏元素各种方式的优劣和各自的适用场景
opacity：0,该元素隐藏起来了，但不会改变页面布局，并且，如果该元素已经绑定了一些事件，如click事件也能触发
visibility:hidden,该元素隐藏起来了，但不会改变页面布局，但是不会触发该元素已经绑定的事件
display:none, 把元素隐藏起来，并且会改变页面布局，可以理解成在页面中把该元素删掉
z-index=-1：置于其他元素下面

* 结构上：
    * display:none 会从渲染树中消失，元素不占据空间且无法点击；
    * visibility: hidden 不会从渲染树中消失，元素继续占据空间但无法点击；
    * opacity: 0 不会从渲染树消失，元素占据空间且可点击。
* 继承性：
    * display: none和opacity: 0是非继承属性；父元素设置了 display:none 或 opacity: 0，子元素无论怎么设置都无法显示；visibility: hidden 会被子元素继承，并且子元素可以通过设置设置 visibility: visible; 来取消隐藏。
* 性能上：
    * display: none;会引起重排，性能消耗较大；
    * visibility: hidden 会引起重绘，性能消耗相对较小；
    * opacity: 0 会重建图层，性能较高
## 6. link标签和import标签的区别
1. link属于html标签，而@import是CSS提供的；
2. 页面被加载时，link会同时被加载，而@import引用的 CSS会等到页面加载结束后加载；
3. link标签样式的权重高于@import的；
4. link可以使用js动态引入(通过动态创建link标签，并为其指定src属性值)，@import不行；
5. link标签没有兼容性要求，而@import要求IE5以上才能识别。

## 7. 说说flex布局以及其应用场景
采用 Flex 布局的元素，称为 Flex 容器（flex container），简称"容器"。它的所有子元素自动成为容器成员，称为 Flex 项目（flex item），简称项目。
<img :src="$withBase('/interview/flex.png')" alt="">
<img :src="$withBase('/interview/flex2.png')" alt="">

Flex(Flexible Box)，也就是`弹性布局`，它可以很灵活地实现垂直居中、多列布局等自适应问题。而任何一个容器都可以指定为Flex布局。设为Flex布局以后，子元素的float、clear和vertical-align属性将失效。
## 8. 移动端Retina，1px像素问题的解决方案
* viewport + rem
* background-image
* 伪元素 + transform scale()
* box-shadow
[7 种方法解决移动端 Retina 屏幕 1px 边框问题](https://juejin.im/entry/584e427361ff4b006cd22c7c)
## 9. 文本显示行数控制
### 单行
```css
overflow:hidden;
text-overflow:ellipsis;
white-space:nowrap;
```
### 多行
```css
overflow: hidden;
text-overflow: ellipsis; // 超出显示'...'
display: -webkit-box; // 将元素作为弹性伸缩盒子模型显示 。
-webkit-line-clamp: 2; // 用来限制在一个块元素显示的文本的行数
-webkit-box-orient: vertical; // 设置或检索伸缩盒对象的子元素的排列方式
```
## 10. 清除浮动的方式
* :after伪类
```css
.clearfix:after {
  visibility: hidden;
  display: block;
  font-size: 0;
  content: " ";
  clear: both;
  height: 0;
}
```
```css
clear: both
```
* 基于BFC原理
```css
overflow: hidden
```
1. 在浮动元素后面添加 clear:both 的空 div 元素，
```html
<div class="container">
    <div class="left"></div>
    <div class="right"></div>
    <div style="clear:both"></div>
</div>
```
2. 给父元素添加overflow: hidden或者auto样式，触发BFC。
```html
<div class="container">
    <div class="left"></div>
    <div class="right"></div>
</div>
```
```css
container {
    width: 300px;
    background-color: #aaa;
    overflow:hidden;
    zoom:1;   /*IE6*/
}
```
3. 使用伪元素，也是在元素末尾添加一个点并带有 clear: both 属性的元素实现的。
```html
<div class="container clearfix">
    <div class="left"></div>
    <div class="right"></div>
</div>
```
```css
.clearfix{
    zoom: 1; /*IE6*/
}
.clearfix:after{
    content: ".";
    height: 0;
    clear: both;
    display: block;
    visibility: hidden;
}
```
推荐使用第三种方法，不会在页面新增div，文档结构更加清晰。

## 11. position 都有哪些值？各个值之间的区别是什么？
- static: 默认值。没有定位，元素出现在正常的文档流中。
- absolute: 绝对定位元素，相对于 static 定位以外的第一个父元素来进行定位。
- fixed: 固定定位元素，相对于浏览器窗口进行定位。
- relative: 相对定位元素，相对于其本身在文档流中的位置进行定位。
- sticky: 粘性定位元素。
- inherit: 规定应该从父元素继承 position 属性的值。

### absolute与fixed的共同点和区别？
* absolute绝对定位 相对于最近的已定位的祖先元素, 有已定位(指position不是static的元素)祖先元素, 以最近的祖先元素为参考标准。如果无已定位祖先元素, 以body元素为偏移参照基准, 完全脱离了标准文档流。
* fixed固定定位的元素会相对于视窗来定位,这意味着即便页面滚动，它还是会停留在相同的位置。一个固定定位元素不会保留它原本在页面应有的空隙。

共同点：改变行内元素的呈现方式，都脱离了文档流；
不同点：absolute的`根元素`是可以设置的，fixed的`根元素`固定为浏览器窗口。
**共同点:**

- 改变行内元素的呈现方式，display 被置为 block;
- 让元素脱离文档流，不占据空间;
- 默认会覆盖到非定位元素上。
  **区别:**
- absolute的定位元素是可以设置的(距离它最近的定位不是 static 的父元素)；
- fixed是相对于浏览器窗口进行定位。当页面滚动时，fixed 元素与浏览器窗口之间的距离是固定不变的。
## 12. 纯CSS实现一个扇形
```css
.sector {
  width: 0;
  height: 0;
  border-width: 50px;
  border-style: solid;
  border-color: red transparent transparent;
  border-radius: 50px;
}
```
## 13. CSS3有哪些新特性？
- 动画(animation)
- 圆角(border-radius)
- 阴影(box-shadow)
- 文字阴影(text-shadow)
- 文字渲染(text-decoration)
- 渐变效果(gradient)
- 拉伸，压缩，旋转，偏移等变换(transform)
- 过渡效果(transition)
- 媒体查询
- 多栏布局
- border-image(背景边框)等

### transition和animate有何区别?
* transition：用于做过渡效果，没有帧概念，只有开始和结束状态，性能开销较小
* animate：用于做动画，有帧的概念，可以重复触发且有中间状态，性能开销较大
### transition和animation的区别
Animation和transition大部分属性是相同的，他们都是随时间改变元素的属性值，他们的主要区别是transition需要触发一个事件才能改变属性，而animation不需要触发任何事件的情况下才会随时间改变属性值，并且transition为2帧，从from .... to，而animation可以一帧一帧的。

Animation功能与Transition功能相同，都是通过改变元素的属性值来实现动画效果的，他们的区别在于：使用Transition功能时只能通过指定属性的开始值和结束值，然后在这两个属性值之间进行平滑过渡的方式来实现动画效果，因此不能实现比较复杂的动画效果。
Animation功能通过定义多个关键帧以及定义每个关键帧中元素的属性值来实现更为复杂的动画效果
```css
// 旋转/缩放/定位/倾斜
transform: rotate(9deg) scale(0.85, 0.9) translate(0px, -30px) skew(-9deg, 0deg);
```
### CSS3动画性能的问题
在做CSS3动画的时候，如果使用gpu渲染图形，可以减少cpu的消耗，提高程序的性能。
当我们使用动画改变图片的left值时候，通常会使用margin-left的属性，但是margin-left属性的时候会触发页面的重绘和重排。当我们使用css3新属性transform来代替传统的margin-left来改变元素位置的时候，不会触发任何的重绘。而且会触发gpu来帮助页面的排版。
