---
title: 8. 浏览器相关知识总结
---
[TOC]
从输入URL到呈现页面过程
强缓存、协商缓存、CDN缓存
HTTP2
HTTP状态码
三次握手与四次挥手
跨域（JSONP/CORS）
跨域时如何处理cookie
垃圾回收机制
## 浏览器
### 浏览器架构
* 用户界面
* 主进程
* 内核
    * 渲染引擎
    * JS 引擎
        * 执行栈
    * 事件触发线程
        * 消息队列
            * 微任务
            * 宏任务
    * 网络异步线程
    * 定时器线程
### 浏览器渲染机制或者说浏览器渲染的主要流程
DOM -> CSSOM -> render -> layout -> print

流程：解析html以及构建dom树 -> 构建render树 ->  布局render树 -> 绘制render树
概念：1.构建DOM树： 渲染引擎解析HTML文档，首先将标签转换成DOM树中的DOM node(包括js生成的标签)生成内容树
      2.构建渲染树： 解析对应的css样式文件信息（包括js生成的样式和外部的css）
      3.布局渲染树：从根节点递归调用，计算每一个元素的大小，位置等。给出每个节点所在的屏幕的精准位置
      4.绘制渲染树：遍历渲染树，使用UI后端层来绘制每一个节点

1. 将html代码按照深度优先遍历来生成DOM树。
2. css文件下载完后也会进行渲染，生成相应的CSSOM。
3. 当所有的css文件下载完且所有的CSSOM构建结束后，就会和DOM一起生成Render Tree。
4. 接下来，浏览器就会进入Layout环节，将所有的节点位置计算出来。
5. 最后，通过Painting环节将所有的节点内容呈现到屏幕上。

<hr>

1. 构建DOM树（parse）：渲染引擎解析HTML文档，首先将标签转换成DOM树中的DOM node
2. 构建渲染树（construct）：解析对应的CSS样式文件信息
3. 布局渲染树（reflow/layout）：从根节点递归调用，计算每一个元素的大小、位置等，给出每个节点所应该在屏幕上出现的精确坐标；
4. 绘制渲染树（paint/repaint）：遍历渲染树，使用UI后端层来绘制每个节点。
### 重绘和重排
重绘（repaint或redraw）：当盒子的位置、大小以及其他属性，例如颜色、字体大小等到确定下来之后，浏览器便把这些颜色都按照各自的特性绘制一遍，将内容呈现在页面上。此时由于只需要UI层面的重新像素绘制，因此**损耗较少**。

重绘是指一个**元素外观的改变**所触发的浏览器行为，浏览器会根据元素的新属性重新绘制，使元素呈现新的外观。

>触发重绘的条件：改变元素外观属性。如：color，background-color等

**注意：table及其内部元素需要多次计算才能确定好其在渲染树中节点的属性值，比同等元素要多花时间，要尽量避免使用table布局**。

重排（回流/reflow）：当渲染树中的一部分（或全部）因为元素的规模尺寸，布局，隐藏等改变而需要重新构建，这就是回流。此时，**浏览器需要重新经过计算，计算后还需要重新页面布局，因此是较重的操作**。

**每个页面都至少需要一次回流，就是页面第一次加载的时候**。

>重排必定会引发重绘，但重绘不一定会引发重排。

触发重排的条件：任何页面布局和几何属性的改变都会触发重排：

* 页面初次渲染(无法避免)
* 浏览器窗口大小改变
* 元素尺寸(大小，外边距，边框)、位置、内容发生改变，或者使用动画
* 元素字体大小变化
* 添加或者删除可见的 dom 元素
* 激活 CSS 伪类（例如：:hover）
* 填充内容的改变，比如文本的改变或图片大小改变而引起的计算值宽度和高度的改变
* 查询某些属性或调用某些方法
    * clientWidth、clientHeight、clientTop、clientLeft
    * offsetWidth、offsetHeight、offsetTop、offsetLeft
    * scrollWidth、scrollHeight、scrollTop、scrollLeft
    * getComputedStyle()
    * getBoundingClientRect()
    * scrollTo()

最佳实践:

css
* 避免使用table布局
* 将动画效果应用到position属性为absolute或fixed的元素上

javascript
* 避免频繁操作样式，可汇总后统一一次修改
* 尽量使用class进行样式修改
* 减少dom的增删次数，可使用 字符串拼接 或者 documentFragment 一次性插入
* 极限优化时，修改样式可将其display: none后修改
* 避免多次触发上面提到的那些会触发回流的方法，可以的话尽量用 变量存住

### 浏览器缓存机制理解
这里将浏览器的缓存机制分为3个部分来说：
* 强缓存
* 协商缓存
* 缓存位置

缓存分为强缓存和协商缓存。强缓存不需要向服务器发送请求且返回的状态码是200，协商缓存需要过服务器，协商缓存返回的状态码是304。两类缓存机制可以同时存在，强缓存的优先级高于协商缓存。当执行强缓存时，如若缓存命中，则直接使用缓存数据库中的数据，不再进行缓存协商。
#### 强缓存
* Expires
* cache-control

#### 协商缓存
* Last-Modified 和 If-Modified-Since
* Etag 和 If-None-Match
#### 缓存位置
### 用户输入url到页面呈现的过程
1. 浏览器的地址栏输入URL并按下回车。
2. 浏览器查找当前URL的DNS缓存记录，并比较缓存是否过期。
3. DNS解析：将域名转换为对应的IP。
4. 根据IP建立TCP连接（三次握手）。
5. HTTP发起请求。
6. 服务器处理请求，浏览器接收HTTP响应。
7. 渲染页面，构建DOM树。
8. 关闭TCP连接（四次挥手）。

* DNS 解析
* TCP 三次握手
* 发送请求，分析 url，设置请求报文(头，主体)
* 服务器返回请求的文件 (html)
* 浏览器渲染
    * HTML parser --> DOM Tree
        * 标记化算法，进行元素状态的标记
        * dom 树构建
    * CSS parser --> Style Tree
        * 解析 css 代码，生成样式树
    * attachment --> Render Tree
        * 结合 dom树 与 style树，生成渲染树
    * layout: 布局
    * GPU painting: 像素绘制页面

### CDN缓存
#### CDN（内容分发网络）
1.尽可能的避开互联网有可能影响数据传输速度和稳定性的瓶颈和环节。使内容传输的更快更稳定。
2.关键技术：内容存储和分发技术中
3.基本原理：广泛采用各种缓存服务器，将这些缓存服务器分布到用户访问相对的地区或者网络中。当用户访问网络时利用全局负载技术将用户的访问指向距离最近的缓存服务器，由缓存服务器直接相应用户的请求（全局负载技术）。
### 为什么css放在顶部而js写在后面
1.浏览器预先加载css后，可以不必等待HTML加载完毕就可以渲染页面了
2.其实HTML渲染并不会等到完全加载完在渲染页面，而是一边解析DOM一边渲染。
3.js写在尾部，主要是因为js主要扮演事件处理的功能，一方面很多操作是在页面渲染后才执行的。另一方面可以节省加载时间，使页面能够更加的加载，提高用户的良好体验

但是随着JS技术的发展，JS也开始承担页面渲染的工作。比如我们的UI其实可以分被对待，把渲染页面的js放在前面，时间处理的js放在后面。
### 跨标签页通讯
不同标签页间的通讯，本质原理就是去运用一些可以 共享的中间介质，因此比较常用的有以下方法:

* 通过父页面window.open()和子页面postMessage
    * 异步下，通过`window.open('about: blank')` 和 `tab.location.href = '*'`
* 设置同域下共享的localStorage与监听window.onstorage
    * 重复写入相同的值无法触发
    * 会受到浏览器隐身模式等的限制
* 设置共享cookie与不断轮询脏检查(setInterval)
* 借助服务端或者中间层实现

## Web安全
https
什么是xss，如何预防
什么是csrf，如何预防
为什么会造成csrf攻击

1.sql注入原理：是将sql代码伪装到输入参数中，传递到服务器解析并执行的一种攻击手法。也就是说，
            在一些对server端发起的请求参数中植入一些sql代码，server端在执行sql操作时，会拼接对应参数，
            同时也将一些sql注入攻击的“sql”拼接起来，导致会执行一些预期之外的操作。
		防范：1.对用户输入进行校验
		       2.不适用动态拼接sql
2.XSS（跨站脚本攻击）：往web页面插入恶意的html标签或者js代码。
		        举例子：在论坛放置一个看是安全的链接，窃取cookie中的用户信息
			防范：1.尽量采用post而不使用get提交表单
			      2.避免cookie中泄漏用户的隐式
3.CSRF(跨站请求伪装）：通过伪装来自受信任用户的请求
			举例子：黄轶老师的webapp音乐请求数据就是利用CSRF跨站请求伪装来获取QQ音乐的数据
			防范：在客服端页面增加伪随机数，通过验证码
XSS和CSRF的区别：
   1.XSS是获取信息，不需要提前知道其他用户页面的代码和数据包
   2.CSRF代替用户完成指定的动作，需要知道其他页面的代码和数据包

### 什么是XSS，如何预防
XSS：跨站脚本攻击，是一种网站应用程序的安全漏洞攻击，是代码注入的一种。常见方式是将恶意代码注入合法代码里隐藏起来，再诱发恶意代码，从而进行各种各样的非法活动。

防范：记住一点，**所有用户输入都是不可信的**，所以得做输入过滤和转义

XSS攻击: 注入恶意代码
* cookie 设置 httpOnly
* 转义页面上的输入内容和输出内容

[对于跨站脚本攻击（XSS攻击）的理解和总结](http://www.imooc.com/article/13553)
#### 预防手段
* 转义字符
* 开启CSP
* cookie设置httpOnly(并不能防止XSS攻击，只是限制js不能操作cookie)
#### Content-Security-Policy细节实现
### 什么是CSRF，如何预防
CSRF：跨站请求伪造，也称 XSRF，是一种挟制用户在当前已登录的Web应用程序上执行非本意的操作的攻击方法。与XSS相比，XSS利用的是用户对指定网站的信任，CSRF利用的是网站对用户网页浏览器的信任。

CSRF中文名为跨站请求伪造。原理就是攻击者构造出一个后端请求地址，诱导用户点击或者通过某些途径自动发起请求。如果用户是在登录状态下的话，后端就以为是用户在操作，从而进行相应的逻辑。

防范：用户操作验证（验证码），额外验证机制（token使用）等

CSRF: 跨站请求伪造，防护:
* get 不修改数据
* 不被第三方网站访问到用户的cookie
* 设置白名单，不被第三方网站请求
* 请求校验
#### 预防手段
* SameSite：可以对Cookie设置 SameSite 属性。该属性表示 Cookie 不随着跨域请求发送，可以很大程度减少 CSRF 的攻击，但是该属性目前并不是所有浏览器都兼容。
* 验证Referer：对于需要防范 CSRF 的请求，我们可以通过验证 Referer 来判断该请求是否为第三方网站发起的。
* Token：用户登录页面，登录成功后，服务器端会生成一个token，放在用户的session或cookie当中，以后每次客户端与服务器端交互的时候都会把该token带过去，服务器端获取该token与自己服务器端保存的token对比，如果相同的话，说明是安全的，否则的话，会拒绝该请求的。

[对于跨站伪造请求（CSRF）的理解和总结](http://www.imooc.com/article/13552)
### XSS和CSRF区别
跨站脚本攻击（Cross Site Scripting)，为了不和层叠样式表 CSS 混淆，故将跨站脚本攻击缩写为 XSS。恶意攻击者往Web页面里注入恶意的Script代码，当用户浏览该页面时，嵌入其中的Script 代码会被执行，从而达到恶意攻击用户的目的。

跨站请求伪造（Cross-site request forgery），是伪造请求，冒充用户在站内的正常操作。我们知道，绝大多数网站是通过cookie等方式辨识用户身份，再予以授权的。所以，要伪造用户的正常操作，最好的方法是通过XSS或链接欺骗等途径，让用户在本机（即拥有身份cookie的浏览器端）发起用户所不知道的请求。

CSRF(Cross-site Request Forgery), 中文名字叫：跨站请求伪造。那么什么是跨站请求伪造呢？就是用户登录一个正常的网站后，由于没有退出该正常网站，cookie信息还保留，然后用户去点击一个危险的网站页面，那么这个时候危险网站就可以拿到你之前登录的cookie信息。然后使用cookie信息去做一些其他事情。

因此，要完成一次CSRF攻击，需要完成如下事情：
1. 登录受信任的网站A，并且在本地生成cookie。
2. 在不登出网站A的情况下，继续访问危险网站B。

区别：
* 原理不同，CSRF是利用网站本身的漏洞，去请求网站的api；XSS是向目标网站注入JS代码，然后执行JS里的代码。
* CSRF需要用户先登录目标网站获取cookie，而XSS不需要登录
* CSRF的目标是用户，XSS的目标是服务器
* XSS是利用合法用户获取其信息，而CSRF是伪造成合法用户发起请求

## 前端性能优化
首屏加载如何优化
一个网页从请求到呈现花了很长时间，如何排查
### 编码优化
1. 减少 cookie 体积: 能有效减少每次请求的体积和响应时间；
* 去除不必要的 cookie；
* 压缩 cookie 大小；
* 设置 domain 与 过期时间；
2. dom 优化:
* 减少访问 dom 的次数，如需多次，将 dom 缓存于变量中；
* 减少重绘与回流:
    * 多次操作合并为一次；
    * 减少对计算属性的访问；
        * 例如 offsetTop， getComputedStyle 等
        * 因为浏览器需要获取最新准确的值，因此必须立即进行重排，这样会破坏了浏览器的队列整合，尽量将值进行缓存使用；

    * 大量操作时，可将 dom 脱离文档流或者隐藏，待操作完成后再重新恢复；
    * 使用DocumentFragment / cloneNode / replaceChild进行操作；
* 使用事件委托，避免大量的事件绑定；

3. css 优化:
* 层级扁平，避免过于多层级的选择器嵌套；
* 特定的选择器 好过一层一层查找:  .xxx-child-text{} 优于 .xxx .child .text{}
* 减少使用通配符与属性选择器；
* 减少不必要的多余属性；
* 使用 动画属性 实现动画，动画时脱离文档流，开启硬件加速，优先使用 css 动画；
* 使用`<link>`替代原生 @import；

4. html 优化:
* 减少 dom 数量，避免不必要的节点或嵌套；
* 避免`<img src="" />`空标签，能减少服务器压力，因为 src 为空时，浏览器仍然会发起请求
    * IE 向页面所在的目录发送请求；
    * Safari、Chrome、Firefox 向页面本身发送请求；
    * Opera 不执行任何操作。
* 图片提前 指定宽高 或者 脱离文档流，能有效减少因图片加载导致的页面回流；
* 语义化标签 有利于 SEO 与浏览器的解析时间；
* 减少使用 table 进行布局，避免使用<br />与<hr />；
### 页面基础优化
1. 引入位置: css 文件`<head>`中引入， js 文件`<body>`底部引入；
    * 影响首屏的，优先级很高的 js 也可以头部引入，甚至内联；
2. 减少请求 (http 1.0 - 1.1)，合并请求，正确设置 http 缓存；
3. 减少文件体积:
    * 删除多余代码:
        * tree-shaking
        * UglifyJs
        * code-spliting
    * 混淆 / 压缩代码，开启 gzip 压缩；
    * 多份编译文件按条件引入:
        * 针对现代浏览器直接给 ES6 文件，只针对低端浏览器引用编译后的 ES5 文件；
        * 可以利用`<script type="module"> / <script type="module">`进行条件引入用
    * 动态 polyfill，只针对不支持的浏览器引入 polyfill；
4. 图片优化:
    * 根据业务场景，与UI探讨选择 合适质量，合适尺寸；
    * 根据需求和平台，选择 合适格式，例如非透明时可用 jpg；非苹果端，使用 webp；
    * 小图片合成 雪碧图，低于 5K 的图片可以转换成 base64 内嵌；
    * 合适场景下，使用 iconfont 或者 svg；
5. 使用缓存:
    * 浏览器缓存: 通过设置请求的过期时间，合理运用浏览器缓存；
    * CDN缓存: 静态文件合理使用 CDN 缓存技术；
    * HTML 放于自己的服务器上；
        * 打包后的图片 / js / css 等资源上传到 CDN 上，文件带上 hash 值；
        * 由于浏览器对单个域名请求的限制，可以将资源放在多个不同域的 CDN 上，可以绕开该限制；
    * 服务器缓存: 将不变的数据、页面缓存到 内存 或 远程存储(redis等) 上；
    * 数据缓存: 通过各种存储将不常变的数据进行缓存，缩短数据的获取时间；

###  首屏渲染优化
1. css / js 分割，使首屏依赖的文件体积最小，内联首屏关键 css / js；
2. 非关键性的文件尽可能的 异步加载和懒加载，避免阻塞首页渲染；
3. 使用dns-prefetch / preconnect / prefetch / preload等浏览器提供的资源提示，加快文件传输；
4. 谨慎控制好 Web字体，一个大字体包足够让你功亏一篑；
    * 控制字体包的加载时机；
    * 如果使用的字体有限，那尽可能只将使用的文字单独打包，能有效减少体积；
5. 合理利用 Localstorage / server-worker 等存储方式进行 数据与资源缓存；
6. 分清轻重缓急:
    * 重要的元素优先渲染；
    * 视窗内的元素优先渲染；
7. 服务端渲染(SSR):
    * 减少首屏需要的数据量，剔除冗余数据和请求；
    * 控制好缓存，对数据/页面进行合理的缓存；
    * 页面的请求使用流的形式进行传递；
8. 优化用户感知:
    * 利用一些动画 过渡效果，能有效减少用户对卡顿的感知；
    * 尽可能利用 骨架屏(Placeholder) / Loading 等减少用户对白屏的感知；
    * 动画帧数尽量保证在 30帧 以上，低帧数、卡顿的动画宁愿不要；
    * js 执行时间避免超过 100ms，超过的话就需要做:
        * 寻找可 缓存 的点；
        * 任务的 分割异步 或 web worker 执行；

### 谈谈前端性能优化？
减少 HTTP请求数
从设计实现层面简化页面
合理设置 HTTP缓存
资源合并与压缩
合并CSS图片，减少请求数的又一个好办法。
将外部脚本置底（将脚本内容在页面信息内容加载后再加载）
多图片网页使用图片懒加载。
在js中尽量减少闭包的使用
尽量合并css和js文件
尽量使用字体图标或者SVG图标，来代替传统的PNG等格式的图片
减少对DOM的操作
在JS中避免“嵌套循环”和 “死循环”
尽可能使用事件委托（事件代理）来处理事件绑定的操作


①减少HTTP请求：合并文件、CSS精灵(雪碧图)、inline Image
②减少DNS查询：DNS查询完成之前浏览器不能从这个主机下载任何任何文件。方法：DNS缓存、将资源分布到恰当数量的主机名，平衡并行下载和DNS查询
③避免重定向：多余的中间访问
④使Ajax可缓存
⑤非必须组件延迟加载和未来所需组件预加载
⑥减少DOM元素数量
⑦将资源放到不同的域下：浏览器同时从一个域下载资源的数目有限，增加域可以提高并行下载量
⑧减少iframe数量

* 使用CDN
* gzip压缩
* 文本压缩
* 合并请求
* 雪碧图
* 图片懒加载
* 缓存资源
* 减少DOM操作
### 首屏加载如何优化
1. 一个网页从请求到呈现花了很长时间，如何排查


## 参考文档
1. [浏览器灵魂之问，请问你能接得住几个？](https://juejin.im/post/5df5bcea6fb9a016091def69#heading-102)
2. [浏览器层合成与页面渲染优化](https://juejin.im/post/5da52531518825094e373372#heading-0)
3. [浏览器工作原理](http://taligarsiel.com/Projects/howbrowserswork1.htm)