---
title: 8. Generator(生成器)
---
## 什么是Generator函数
1. ES6提供的异步编程解决方案之一。
2. Generator函数是一个状态机，内部封装了不同状态的数据。
3. 用来生成遍历器对象(iterator接口)，调用Generator函数并不会执行其内部的代码，而是返回一个遍历器对象。
4. 可暂停函数(惰性求值)，yield可暂停，next方法可继续执行，每次返回的是yield后的表达式结果。

## Generator函数特点
1. function关键字与函数名之间有一个`*`星号。
2. 内部用yield表达式来定义不同的状态。
3. 调用generator函数返回的是一个遍历器对象，而不会执行函数内部逻辑。
4. 调用next方法，函数内部逻辑开始执行，遇到yield表达式停止，返回{value: yield后的表达式结果/undefined, done: false/true}。
5. 再次调用next方法会从上一次停止时的yield处开始，直到下一个yield表达式停止或者最后。
6. yield语句返回结果通常为undefined，当调用next方法时传参内容会作为启动时yield语句的返回值。

```js
function* generatorExample() {
    let result = yield 'hello'; // 状态值(value)为hello
    yield 'world'; // 状态值(value)为world
}
```
```js
function* generatorTest() {
    console.log('函数开始执行');
    let res = yield 'hello'; // yield语句返回结果默认是为undefined
    console.log(res); // '我是next传入的值'
    console.log('函数继续执行');
    yield 'world';
}

const gen = generatorTest();
console.log(gen.next());
// 当调用next方法时传参内容会作为启动时yield语句的返回值
console.log(gen.next('我是next传入的值'));
console.log(gen.next());
```
## 基本语法
Generator函数语法行为与传统函数完全不同。
```js
function* testGenerator() {
    yield 'hello';
    yield 'world';
    return 'end';
}
// 调用Generator函数后，该函数并不执行，返回的也不是函数运行结果，而是一个指向内部状态的指针对象，也就是上一章介绍的遍历器对象
const gen = testGenerator();
```
形式上，`Generator`函数是一个普通函数，但是有两个特征：

1. function关键字与函数名之间有一个星号；
2. 函数体内部使用yield(翻译为产出)表达式，定义不同的内部状态；

上面代码中定义了一个`Generator`函数testGenerator，它内部有两个yield表达式（hello和world），即该函数有三个状态：hello，world 和 return 语句（结束执行）。

然后，`Generator`函数的调用方法与普通函数一样，也是在函数名后面加上一对圆括号。不同的是，调用Generator函数后，该函数并不执行，返回的也不是函数运行结果，而是一个指向内部状态的指针对象，也就是上一章介绍的遍历器对象（Iterator Object）。

下一步，必须调用遍历器对象的next方法，使得指针移向下一个状态。也就是说，每次调用next方法，内部指针就从函数头部或上一次停下来的地方开始执行，直到遇到下一个yield表达式（或return语句）为止。换言之，**Generator函数是分段执行的**，yield表达式是暂停执行的标记，而next方法可以恢复执行。
```js
gen.next();
// value值是yield后的表达式结果
// { value: 'hello', done: false }
gen.next();
// { value: 'world', done: false }
gen.next();
// { value: 'ending', done: true }
gen.next();
// { value: undefined, done: true }
```
上面代码一共调用了四次next方法。
第一次调用，Generator 函数开始执行，直到遇到第一个yield表达式为止。next方法返回一个对象，它的value属性就是当前yield表达式的值hello，done属性的值false，表示遍历还没有结束。

第二次调用，Generator 函数从上次yield表达式停下的地方，一直执行到下一个yield表达式。next方法返回的对象的value属性就是当前yield表达式的值world，done属性的值false，表示遍历还没有结束。

第三次调用，Generator 函数从上次yield表达式停下的地方，一直执行到return语句（如果没有return语句，就执行到函数结束）。next方法返回的对象的value属性，就是紧跟在return语句后面的表达式的值（如果没有return语句，则value属性的值为undefined），done属性的值true，表示遍历已经结束。

第四次调用，此时 Generator 函数已经运行完毕，next方法返回对象的value属性为undefined，done属性为true。以后再调用next方法，返回的都是这个值。

::: tip
总结一下：调用Generator函数，返回一个遍历器对象，代表 Generator 函数的内部指针。以后，每次调用遍历器对象的next方法，就会返回一个有着value和done两个属性的对象。value属性表示当前的内部状态的值，是yield表达式后面那个表达式的值；done属性是一个布尔值，表示是否遍历结束。
:::
## 给对象添加iterator接口
```js
const objIterable = {};
objIterable[Symbol.iterator] = function* () {
    yield 'hello';
    yield 'world';
    yield 'end';
}

for (const i of objIterable) {
    console.log(i);
}

const obj = [...objIterable];
console.log(obj); // [ 'hello', 'world', 'end' ]
```
输出结果如下：
```js
hello
world
end
[ 'hello', 'world', 'end' ]
```
## Generator函数实例应用
1. 发送ajax请求获取新闻内容。
2. 新闻内容获取成功后再次发送请求，获取对应的新闻评论。
3. 新闻内容获取失败则不需要再次发送请求。

```js
function* sendRequest() {
    const url = yield getData('http://www.example.com/news?newsID=123');
    yield getData(url);
}

function getData(url) {
    $.get(url, data => {
        console.log(data);
        const commentsUrl = data.commentsUrl;
        const resUrl = `http://www.example.com/${commentsUrl}`;
        // 当获取新闻内容成功，发送请求获取对应的评论内容
        // 调用next传参会作为上次暂停是yield的返回值
        gen.next(resUrl);
    });
}

const gen = sendRequest();
gen.next(); // 发送获取新闻内容请求
```
## Generator函数的异步应用
### Thunk
```js

```
### co模块
co模块的主要作用是：用于Generator函数的自动执行。
来看个🌰：
```js
const {fs} = require('mz');
const co = require('co');
function* gen() {
    // 依次读取两个文件
    const name = yield fs.readFile('./name.txt', 'utf8');
    const age = yield fs.readFile('./age.txt', 'utf8');
    console.log(name.toString());
    console.log(age.toString());
}

co(gen);
```
上面代码中，Generator函数只要传入co函数，就会自动执行。输出结果如下：
```js
lisi
18
```
co函数返回一个Promise对象，因此可以用then方法添加回调函数。
```js
co(gen).then(() => {
    console.log('gen函数执行完毕');
});
```
上面代码中，等到Generator函数执行结束，就会输出一行提示。

```js
// mz模块把node中的一些常用模块promise化了
const {fs} = require('mz');
function* read() {
    let filename = yield fs.readFile('./name.txt', 'utf8');
    let age = yield fs.readFile(filename, 'utf8');
    let b = yield [1, 2, 3];
    return age + b;
}
// const co = require('co');
// 实现co
function co(it) {// express koa
    // 返回的是Promise
    return new Promise((resolve, reject) => {
        function next(r) { //如果碰到异步迭代 需要借助一个自执行函数来实现，保证第一次执行后调用下一次执行
            const {value, done} = it.next(r);
            if(!done) { // babel
                // 不管value是什么类型，都包装成promise
                Promise.resolve(value).then(r => {
                    next(r);
                }, err => {
                    reject(err);
                });
            } else { // 完成了走成功
                resolve(value);
            }
        }
        next();
    });
}
// co接收generator参数，返回的是Promise
co(read()).then(data=>{
    console.log(data);
});
```
## 参考文档
1. [Generator 函数的语法](http://es6.ruanyifeng.com/#docs/generator)