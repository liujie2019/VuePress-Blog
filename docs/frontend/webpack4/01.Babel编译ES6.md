---
title: 1. Babel编译ES6+和JSX
---

## loader作用
loader作用就是：把项目使用到的文件转化成指定的格式文件输出。
webpack无法识别非`.js`结尾的模块，因此需要配置对应的loader来进行转换。`babel-loader`就是用于将`ES6+`语法转换成ES5语法的。

## Babel相关npm包

* babel-loader
* @babel/preset-env: 将ES6+转换成ES5；
* @babel/polyfill: 转换内置API和函数；
* @babel/plugin-transform-runtime: 主要用于第三方库的打包，避免polyfill污染全局变量。

需要注意的是：
* @babel/preset-env只负责语法转化，比如：箭头函数、class等；
* @babel/polyfill负责内置API和函数，比如：Set、Map、Promise、includes等。

::: tip
1. 处理项目中的业务逻辑采用：@babel/preset-env + @babel/polyfill
2. 第三方库的打包采用：@babel/plugin-transform-runtime + @babel/transform-runtime
:::

## 业务代码打包
```js
yarn add @babel/core babel-loader @babel/preset-env -D
```
在项目根目录新建一个`.babelrc`文件，内容为：
```js
{
  "presets": ["@babel/preset-env"]
}
```
```js
// webpack.config.js
const path = require('path');

module.exports = {
  entry: './src/index.js',
  output: {
    filename: 'bundle.js',
    path: path.resolve(__dirname, 'dist')
  }
  module: {
    rules: [
      {
        test: /\.js$/,
        exclude: /node_modules/,
        use: {
          loader: 'babel-loader'
        }
      }
    ]
  }
};
```
## @babel/polyfill引入
node中引入：
```js
require('@babel/polyfill');
```
如果在应用入口使用`ES6`的`import`语法，需要在入口顶部通过`import`将`polyfill`引入，以确保它能够最先加载：
```js
import '@babel/polyfill';
```
在`webpack.config.js`中，将`@babel/polyfill`加到entry 数组中：
```js
module.exports = {
  entry: ['@babel/polyfill', './src/index.js']
};
```
## 在npm scripts中使用babel-loader(不推荐)
`--module-bind`参数允许我们在命令行中指定加载器。该参数从`webpack3`开始就有了。

如果希望在没有配置文件的情况下使用`babel-loader`，需要在 `package.json`中配置`npm scripts`，如下所示：
```js
"scripts": {
    "dev": "webpack --mode development --module-bind js=babel-loader",
    "build": "webpack --mode production --module-bind js=babel-loader"
}
```
运行`npm run build`构建项目。

## 转化generator
![1701917709ba87da89ec95299b857c5e.png](evernotecid://AC85336C-B325-443E-8ED7-E6554790A944/appyinxiangcom/10797539/ENResource/p1224)
## 编译JSX
>1. 安装`React`：
```js
npm i react react-dom --save-dev
```
>2. 安装`babel-preset-react`：
```js
npm i @babel/preset-react --save-dev
```
>3. 在`.babelrc`中配置预设：
```js
// 需要注意preset的执行顺序是从右向左，从下往上的。
{
  "presets": [
    "@babel/preset-env",
    "@babel/preset-react"
   ]
}
```
这样一来，我们可以配置`babel-loader`来读取`.jsx`文件。具体配置如下：
```js
module.exports = {
  module: {
    rules: [
      {
        test: /\.(js|jsx)$/,
        exclude: /node_modules/,
        use: {
          loader: 'babel-loader'
        }
      }
    ]
  }
};
```
在`./src/App.js`中创建一个测试的`React`组件：
```js
import React from "react";
import ReactDOM from "react-dom";
const App = () => {
  return (
    <div>
      <p>React Test!</p>
    </div>
  );
};
export default App;
```
接下来在`./src/index.js`中导入组件：
```js
import React from "react";
import ReactDOM from "react-dom";
import App from "./App";
ReactDOM.render(
    <App />,
    document.getElementById("app")
);
```
然后再次运行构建`yarn run build`。
