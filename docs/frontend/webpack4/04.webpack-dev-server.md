---
title: 4. webpack-dev-server
---
## DevServer配置项详解
要配置`DevServer`，除了可以在配置文件里通过devServer传入参数，还可以通过命令行参数传入。**需要注意的是：** 只有在通过`DevServer`启动Webpack时，配置文件里的`devServer`才会生效，因为这些参数所对应的功能都是`DevServer`提供的，Webpack本身并不认识`devServer`配置项。
### devServer.hot
`devServer.hot`配置模块热替换功能。`DevServer`的默认行为是：在发现源代码被更新后通过自动刷新整个页面来做到实时预览，开启模块热替换功能后，将在不刷新整个页面的情况下通过用新模块替换老模块来做到实时预览。
### devServer.inline
`DevServer`的实时预览功能依赖一个注入页面里的代理客户端去接收来自`DevServer`的命令并负责刷新网页的工作。`devServer.inline`用于配置是否将这个代理客户端自动注入将运行在页面中的Chunk里，默认自动注入。`DevServer`会根据我们是否开启`inline`来调整它的自动刷新策略。

1. 开启inline，则`DevServer`会在构建变化后的代码时通过代理客户端控制网页刷新；
2. 关闭inline，则`DevServer`将无法直接控制要开发的网页。这时它会通过iframe的方式去运行要开发的网页。在构建完变化后的代码时，会通过刷新iframe来实现实时预览，但这时我们需要通过`http://localhost:8080/webpack-dev-server/`实时预览自己的网页。

### devServer.historyApiFallback
`devServer.historyApiFallback`用于方便地开发使用了HTML5 History API的单页应用。这类单页应用要求服务器在针对任何命中的路由时，都返回一个对应的HTML文件。例如：在访问`http://localhost/user`和`http://localhost/home`时都返回`index.html`文件，浏览器端的javascript代码会从url里解析出当前页面的状态，显示对应的界面。

>配置`historyApiFallback`最简单的做法是：
```js
historyApiFallback: true
```
>上述配置会导致任何请求都会返回`index.html`文件，这只能用于只有一个HTML文件的应用。如果应用由多个单页应用组成，则需要`DevServer`根据不同的请求返回不同的HTML文件，配置如下：
```js
historyApiFallback: {
    // 使用正则匹配命中路由
    rewrites: [
        // /user开头的都返回user.html
        {from: /^\/user/, to: '/user.html'},
        // /game开头的都返回user.html
        {from: /^\/game/, to: '/game.html'},
        // 其他的都返回index.html
        {from: /./, to: '/index.html'},
    ]
}
```

### devServer.contentBase
`devServer.contentBase`配置`DevServer`HTTP服务器的文件根目录。在默认情况下为当前的执行目录，通常是项目根目录，所以在一般情况下不需要设置它，除非有额外的文件需要被`DevServer`服务。例如：想将项目根目录下的public目录设置成`DevServer`服务器的文件根目录，则可以这样配置：
```js
devServer: {
    contentBase: path.join(__dirname, 'public')
}
```
>需要注意的是：`DevServer`服务器通过HTTP服务暴露文件的方式分为两类：

1. 暴露本地文件；
2. 暴露Webpack构建出的结果，由于构建出的结果交给了`DevServer`，所以我们在使用`DevServer`时，会在本地找不到构建出的文件。

>`contentBase`只能用来配置暴露本地文件的规则，可以通过`contentBase: false`来关闭暴露本地文件。

### devServer.headers
`devServer.headers`配置项可以在HTTP响应中注入一些HTTP响应头，使用如下：
```js
devServer: {
    headers: {
        'X-foo': 'bar'
    }
}
```
### devServer.host
`devServer.host`配置项用于配置`DevServer`服务监听的地址。默认情况下是`localhost`，如果**想让局域网中的其他设备访问自己的本地服务**，可以这样配置：
```js
module.exports = {
  //...
  devServer: {
    host: '0.0.0.0'
  }
};
```
>命令行使用方式：
```js
webpack-dev-server --host 0.0.0.0
```

### devServer.port
`devServer.port`配置项用于配置`DevServer`服务监听的端口，默认使用8080端口。
### devServer.allowedHosts
`devServer.allowedHosts`配置一个白名单列表，只有HTTP请求的HOST在列表里才正常返回，配置如下：
```js
module.exports = {
  //...
  devServer: {
    allowedHosts: [
      // 匹配单个域名
      'host.com',
      'subdomain.host.com',
      'subdomain2.host.com',
      'host2.com',
      // host.com和所有的子域名*.host.com都将匹配
      '.host.com'
    ]
  }
};
```
### devServer.disableHostCheck
`devServer.disableHostCheck`配置项用于配置是否关闭用于DNS重新绑定的HTTP请求的HOST检查。DevServer默认只接收来自本地的请求，关闭后可以接收来自任意HOST的请求。通常用于搭配`--host 0.0.0.0`使用，因为想让其他设备访问自己的本地服务，但访问时是直接通过IP地址访问而不是通过HOST访问，所以需要关闭HOST检查。
### devServer.https
`DevServer`默认使用HTTP服务，也可以使用HTTPS服务。配置如下：
```js
module.exports = {
  //...
  devServer: {
    https: true
  }
};
```
>`DevServer`会自动为我们生成一份HTTPS证书，如果想使用自己的证书，可以这样配置：
```js
module.exports = {
  //...
  devServer: {
    https: {
      key: fs.readFileSync('/path/to/server.key'),
      cert: fs.readFileSync('/path/to/server.crt'),
      ca: fs.readFileSync('/path/to/ca.pem'),
    }
  }
};
```
### devServer.clientLogLevel
clientLogLevel属性配置客户端的日志等级，这会影响我们在浏览器开发者工具控制台里看到的日志内容。`clientLogLevel`是枚举类型，可取如下值之一：`none、error、warning、info`。默认为`info`级别，即输出所有类型的日志，设置为`none`时可以不输出任何日志。
### devServer.compress
compress属性配置是否启用Gzip压缩，默认为false。
### devServer.open
open属性用于在`DevServer`启动且第一次构建完成时，自动用我们的系统的默认浏览器去打开要开发的网页。还可以使用`devServer.openPage`配置项来打开指定URL的网页。
### devServer.overlay
overlay属性配置在浏览器中显示编译的错误或者警告。

## 配置实战
### watch
webpack提供了`webpack --watch`的命令来动态监听文件的改变并实时打包，输出新的bundle.js文件，这样文件多了之后打包速度会很慢，此外这样的打包的方式不能做到HMR(Hot Module Replacement)，就是每次webpack编译完成之后，我们还需要手动刷新浏览器。
`webpack --watch`
```js
const path = require('path');

module.exports = {
    mode: 'development',
    entry: './src/index.js',
    output: {
        path: path.resolve(__dirname, './dist'),
        filename: 'bundle.js',
        // publicPath: '/assets/'
    },
    // 只有在开启监听模式时，watchOptions才有意义
    // 默认为false，也就是不开启
    watch: true,
    // 监听模式运行时的参数
    // 在开启监听模式时才有意义
    watchOptions: {
        // 不监听的文件或文件夹，支持正则匹配
        // 默认为空
        ignored: /node_modules/,
        // 监听到变化发生后等300ms再去执行动作，截流
        // 防止文件更新太快而导致重新编译频率太快。默认为300ms
        aggregateTimeout: 300,
        // 判断文件是否发生变化是通过不停地询问系统指定文件有没有变化实现的
        // 默认每秒询问1000次
        poll: 1000
    }
}
```
`webpack-dev-server`提供的功能就能解决上面`watch`的2个问题。webpack-dev-server通过启动一个基于express的HTTP服务器。它的作用主要是用来伺服资源文件。
此外，这个HTTP服务器和client使用了websocket通讯协议，原始文件作出改动后，webpack-dev-server会实时的编译，需要注意的是：**实时编译后的文件都保存到了内存当中，也就是说最后编译的文件并没有输出到目标文件夹**。
### content-base
设定webpack-dev-server伺服的目录。如果不进行设定的话，默认是在当前目录下。

>需要注意：入口文件index.html所在目录必须要与webpack-dev-server伺服的目录保持一致，否则访问不成功。如下是我的项目目录：

![e93da36852280ecd1c218eadf9a3f561.png](evernotecid://AC85336C-B325-443E-8ED7-E6554790A944/appyinxiangcom/10797539/ENResource/p791)
>webpack配置如下：
```js
const path = require('path');

module.exports = {
    mode: 'development',
    entry: './src/index.js',
    output: {
        path: path.resolve(__dirname, './dist'),
        filename: 'bundle.js',
        // publicPath: '/assets/'
    },
    devServer: {
        // contentBase: path.join(__dirname, 'dist'),
        compress: true,
        port: 9000,
        host: '0.0.0.0',
        disableHostCheck: false,
        open: true,
        overlay: true,
        noInfo: true
    }
}
```
此时没有设置`contentBase`，webpack-dev-server伺服的目录为当前项目的根目录，与入口文件index.html所在目录一致，因此可以正常访问。

假如将入口文件index.html放到dist目录下，就需要配置：
```js
contentBase: path.join(__dirname, 'dist')
```
### 配置了output的publicPath
```js
output: {
        path: path.resolve(__dirname, './dist'),
        filename: 'bundle.js',
        publicPath: '/assets/'
}
```
```html
<body>
    <button id="btn">我是按钮</button>
    <script src="bundle.js"></script>
</body>
```
>配置了output的publicPath为`'/assets/'`，而index.html文件中bundle.js的引用路径没有改变，则会报文件找不到(404)。

![3e964238f6d2cba100c2252e56ad4bdb.png](evernotecid://AC85336C-B325-443E-8ED7-E6554790A944/appyinxiangcom/10797539/ENResource/p792)
```html
<body>
    <button id="btn">我是按钮</button>
    <script src="/assets/bundle.js"></script>
</body>
```
![57e76328744b989d74ecf81a7863c174.png](evernotecid://AC85336C-B325-443E-8ED7-E6554790A944/appyinxiangcom/10797539/ENResource/p793)
所以，如果配置了output的publicPath字段的值，在index.html文件里面也应该做出调整。因为webpack-dev-server伺服的文件是**相对于publicPath这个路径的**。
### 自动刷新
webpack-dev-server支持2种自动刷新的方式：

* iframe mode
* inline mode(默认方式)

这2种模式配置的方式和访问的路径稍微有点区别，最主要的区别还是`iframe mode`是在网页中嵌入了一个iframe，将我们自己的应用注入到这个iframe当中去，因此每次你修改的文件后，都是这个iframe进行了reload。

默认情况下，应用程序启用内联模式(inline mode)。这意味着一段处理实时重载的脚本被插入到你的包(bundle)中，并且构建消息将会出现在浏览器控制台。
#### iframe mode
当然也可以使用iframe模式，它在通知栏下面使用`<iframe>`标签，包含了关于构建的消息。切换到iframe 模式：
```js
devServer: {
    inline: false
    ...
}
```
>Usage via the CLI
```js
webpack-dev-server --inline=false
```
`Iframe mode`下，浏览器访问的路径是:
`localhost:8080/webpack-dev-server/index.html`。
这个时候这个页面的header部分会出现整个reload消息的状态。当时改变源文件的时候，即可以完成自动编译打包，页面自动刷新的功能。
![2d0f60bbe113d787fc6cb1414434aa9f.png](evernotecid://AC85336C-B325-443E-8ED7-E6554790A944/appyinxiangcom/10797539/ENResource/p796)
通过上图可以看到，
![26c345c1ed6f10dcd1861111d1b561eb.png](evernotecid://AC85336C-B325-443E-8ED7-E6554790A944/appyinxiangcom/10797539/ENResource/p794)

在Iframe mode下，请求`/webpack-dev-server/index.html`路径时，会返回`client/live.html`文件，这个文件的内容如下：
```html
<!DOCTYPE html><html><head><meta http-equiv="X-UA-Compatible" content="IE=edge"/><meta charset="utf-8"/><meta name="viewport" content="width=device-width, height=device-height, initial-scale=1.0, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0"/><script type="text/javascript" charset="utf-8" src="/__webpack_dev_server__/live.bundle.js"></script></head><body></body></html>
```
这个页面会请求client目录下的live.bundle.js，其中里面会新建一个iframe，我们的应用就被注入到了这个iframe当中。同时live.bundle.js中含有`socket.io`的client代码，这样它就能和webpack-dev-server建立的http server进行websocket通讯了。并根据返回的信息完成相应的动作。
#### inline mode
>Usage via the CLI：
```bash
webpack-dev-server --inline
```
>这个时候访问的路径是:
```js
localhost:8080/index.html
```
也能完成自动编译打包，页面自动刷新的功能。但是没有的header部分的reload消息的显示，不过在控制台中会显示reload的状态。
![5b37a827c9c4c38d3d5905aab5ca642a.png](evernotecid://AC85336C-B325-443E-8ED7-E6554790A944/appyinxiangcom/10797539/ENResource/p797)

### HMR(Hot Module Replacement)
HMR可在不刷新整个网页的情况下做到超灵敏实时预览。
开启`HMR`功能，>Usage via the CLI：
```bash
webpack-dev-server --hot --inline
```
```js
const path = require('path');
const webpack = require('webpack');

module.exports = {
    mode: 'development',
    // entry: [
    //     'webpack-dev-server/client?http://localhost:9000/',
    //     'webpack/hot/dev-server',
    //     './src/index.js'
    // ],
    entry: './src/index.js',
    output: {
        path: path.resolve(__dirname, './dist'),
        filename: 'bundle.js'
        // publicPath: '/assets/'
    },
    module: {
        rules: [
            {
                test: /\.css$/,
                use: [ 'style-loader', 'css-loader' ]
            }
        ]
    },
    plugins: [
        new webpack.NamedModulesPlugin(),
        // 该插件的作用是实现模块热替换，实际上若启动时带上--hot参数，就会注入该插件，生成.hot-update.json文件
        new webpack.HotModuleReplacementPlugin()
    ],
    devServer: {
        contentBase: path.join(__dirname, 'dist'),
        compress: true,
        inline: true,
        port: 9000,
        host: '0.0.0.0',
        disableHostCheck: false,
        open: true,
        overlay: true,
        noInfo: true,
        hot: true
    }
}
```
其他配置选项

* --quiet 控制台中不输出打包的信息
* --compress 开启gzip压缩
* --progress 显示打包的进度
## 局域网内访问
```js
host: '0.0.0.0',
disableHostCheck: false
```

## 参考文档
1. [webpack-dev-server使用方法，看完还不会的来找我~](https://segmentfault.com/a/1190000006670084#articleHeader4)
