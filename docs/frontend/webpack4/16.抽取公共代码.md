---
title: 16. 抽取公共代码
---
使用`webpack4`在打包多页面应用过程中，需要提取公共代码。相比于`webpack3`而言，`4.0`版本用`optimization.splitChunks`配置替换了3.0版本的`CommonsChunkPlugin`插件。在使用和配置上，更加方便和清晰。

在使用`splitChunksPlugins`之前，首先要知道`splitChunksPlugins`是`webpack`主模块中的一个细分模块，无需`npm`引入。功能上，`splitChunksPlugins`只能用于如何抽离公用的代码，也就是**抽离公用代码**的规则，要记住，除了这个功能之外，`splitChunksPlugins`再无其他功能。

## 常用参数
* **minSize**(默认是30000，单位是字节)：形成一个新代码块最小的体积；
* **minChunks**（默认是1）：在分割之前，这个代码块最小应该被引用的次数；
* **maxInitialRequests（默认是3）**：一个入口最大的并行加载文件数；
* **maxAsyncRequests（默认是5）**：按需加载的时候，最大的并行请求数；
* **chunks(默认是async)** ：用于配置控制webpack选择哪些代码块用于分割（译注：其他类型代码块按默认方式打包），有3个可选的值：`initial(初始块)、async(按需加载的异步块)和all(所有块)`；`async`表示作用于异步模块，`all`表示作用于所有模块，`initial`表示作用于同步模块；
* **test**：用于规定缓存组匹配的文件位置，`test: /node_modules/`，即为匹配相应文件夹下的模块。原封不动传递出去的话，它默认会选择所有的模块。可以传递的值类型：`RegExp、String和Function`；
* **name(打包的chunks的名字)** ：字符串或者函数(函数可以根据条件自定义名字)；用以控制分离后代码块的命名，当存在匹配的缓存组时，**命名使用缓存组中的name值**，若不存在则为`[来源]~[入口的key值].js`的格式。
* **priority**：缓存组打包的先后优先级。这个是最重要的，即便是所有配置项都写好了，优先级不够，或者优先级设置不正确，也得不到相应的结果。当需要优先匹配缓存组的规则时，priority需要设置为正数，当需要优先匹配默认设置时，缓存组需设置为负数，0为两者的分界点。
* **reuseExistingChunk**：设置该选项允许复用已经存在的代码块，而不是新建一个新的，需要在精确匹配到对应模块时候才会生效；
* **automaticNameDelimiter**：修改上文中的`“~”`，若改为`“-”`，则分离后的`js`默认命名规则为`[来源]-[入口的key值].js`。
* **cacheGroups**：即缓存组，其实就是**存放分离代码块的规则的对象**，叫做`cacheGroup`的原因是`webpack`会将规则放置在`cache`流中，为对应的块文件匹配对应的流，从而生成分离后的块。`cacheGroup`中`priority`为分离规则的优先级，优先级越高，则优先匹配。

## 配置缓存组(Configurate cache group)
>这是默认的配置：

```js
splitChunks: {
    chunks: "async",
    minSize: 30000,
    minChunks: 1,
    maxAsyncRequests: 5,
    maxInitialRequests: 3,
    name: true,
    cacheGroups: {
        default: {
            minChunks: 2,
            priority: -20,
            reuseExistingChunk: true,
        },
        vendors: {
            test: /[\\/]node_modules[\\/]/,
            priority: -10
        }
    }
}
```
>默认来说，`cacheGroups`(缓存组)会继承`splitChunks`的配置，但是`test、priorty和reuseExistingChunk`只能用于配置缓存组。

`cacheGroups`是一个对象，按上述介绍的键值对方式来配置即可，值代表对应的选项。

除此之外，所有上面列出的选项都是可以用在缓存组里的：`chunks， minSize，minChunks，maxAsyncRequests，maxInitialRequests，name`。

可以通过`optimization.splitChunks.cacheGroups.default: false`，来禁用`default`缓存组。

`default`缓存组的优先级(`priotity`)是负数，因此所有自定义缓存组都可以有比它更高优先级（译注：更高优先级的缓存组可以优先打包所选择的模块），默认自定义缓存组优先级为0。

>打包结果：

![dead6af70ba7940654bd4086445751a4.png](evernotecid://AC85336C-B325-443E-8ED7-E6554790A944/appyinxiangcom/10797539/ENResource/p366)

### optimization.runtimeChunk
```js
runtimeChunk: 'single'
// 等价于
runtimeChunk: {
   name: 'runtime'
}
```
>将webpack的运行文件单独打包到一个代码块中。

通过`optimization.runtimeChunk: true`选项，`webpack`会添加一个只包含运行时(runtime)额外代码块到每一个入口。（译注：这个需要看场景使用，会导致每个入口都加载多一份运行时代码）

## 参考文档
1. [官方demo](https://github.com/webpack/webpack/tree/master/examples/common-chunk-and-vendor-chunk)
2. [一步一步的了解webpack4的splitChunk插件](https://juejin.im/post/5af1677c6fb9a07ab508dabb)
