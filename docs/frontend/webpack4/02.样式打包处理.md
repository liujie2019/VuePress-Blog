---
title: 2. 样式打包处理
---
我们都知道，在HTML中引入CSS的方式有`<link>`标签和`<style>`标签两种，下面结合`webpack`来实现以下功能：

1. 将`CSS`通过`link`标签引入；
2. 将`CSS`放在`style`标签里；
3. 动态加载和卸载`CSS`；
4. 页面加载CSS前的transform。

安转需要用到的loader：
```bash
yarn add css-loader style-loader file-loader -D
```

## CSS通过`<link>`标签引入
通过link标签引用css文件，这需要借助`file-loader`来将`css`处理为文件。具体配置如下：
```js
const path = require('path');

module.exports = {
    mode: 'none',
    entry:  './src/index.js',
    output: {
        path: path.resolve(__dirname, 'dist'), // 打包文件的输出目录
        filename: 'bundle.js'
    },
    module: {
        rules: [
            {
                test: /\.css$/,
                use: [
                    {
                        loader: 'style-loader/url'
                    },
                    {
                        loader: 'file-loader'
                    }
                ]
            }
        ]
    }
};
```
入口文件index.js
```js
const isClick = false;
// 点击页面上的按钮后，页面会引入相应的样式
document.querySelector('#btn').addEventListener('click', () => {
    if (!isClick) {
        import('./style/index.css');
    }
});
```
点击加载前：
<img :src="$withBase('/webpack4/css-loader.png')" alt="">

点击加载后：
<img :src="$withBase('/webpack4/css-loader2.png')" alt="">

从上图可以看出，对应的css被插入了相应的`link`标签中。

## CSS放在`<style>`标签里
通常来说，`css`放在`style`标签里可以减少网络请求次数，缩短响应时间。需要注意的是，在老式`IE`浏览器中，对`style`标签的数量是有要求的。具体配置如下：
```js
const path = require('path');

module.exports = {
    mode: 'none',
    entry:  './src/index.js',
    output: {
        path: path.resolve(__dirname, 'dist'), // 打包文件的输出目录
        filename: 'bundle.js'
    },
    module: {
        rules: [
            {
                test: /\.css$/,
                use: [
                    {
                        loader: 'style-loader',
                        options: {
                            singleton: true // 处理为单个style标签
                        }
                    },
                    {
                        loader: 'css-loader'
                    }
                ]
            }
        ]
    }
};
```
点击加载前：
<img :src="$withBase('/webpack4/css-loader3.png')" alt="">

点击加载后：
<img :src="$withBase('/webpack4/css-loader5.png')" alt="">

## 动态卸载和加载CSS
`style-loader`为`css`对象提供了`use()和unuse()`两个方法，借助这两个方法，可以方便快捷地加载和卸载`css`样式。具体配置如下：
```js
const path = require('path');

module.exports = {
    mode: 'none',
    entry:  './src/index.js',
    output: {
        path: path.resolve(__dirname, 'dist'), // 打包文件的输出目录
        filename: 'bundle.js'
    },
    module: {
        rules: [
            {
                test: /\.css$/,
                use: [
                    {
                        loader: 'style-loader/useable',
                    },
                    {
                        loader: 'css-loader'
                    }
                ]
            }
        ]
    }
};
```
入口文件:
```js
import style from './style/index.css';
let flag = false;
setInterval(() => {
    // use和unuse是style上的方法
    if (flag) {
        style.unuse();
    }
    else {
        style.use();
    }
    flag = !flag;
}, 1000);
```
样式不会添加在`import/require()`上，而是在调用`use/ref`时添加，在调用`unuse/unref`时删除。

## 页面加载css前的transform
对于`css`的`transform`，简单来说：在加载`css`样式前，可以更改`css`。这样，方便开发者根据业务需要，对`css`进行相关处理。

需要对`style-loader`增加`options.transform`属性，值为指定的`js`文件，具体的`webpack.config.js`配置如下：
```js
const path = require('path');

module.exports = {
    mode: 'none',
    entry:  './src/index.js',
    output: {
        publicPath: __dirname + '/dist/', // js引用路径或者CDN地址
        path: path.resolve(__dirname, 'dist'), // 打包文件的输出目录
        filename: 'bundle.js'
    },
    module: {
        rules: [
            {
                test: /\.css$/,
                use: [
                    {
                        loader: 'style-loader',
                        options: {
                            transform: './src/transform.js'
                        }
                    },
                    {
                        loader: 'css-loader'
                    }
                ]
            }
        ]
    }
};
```
transform.js：
```js
module.exports = function (css) { // 传入的参数是css字符串本身
    console.log(css);
    const transformed = css.replace('yellow', 'green')
    // 如果屏幕宽度小于800，则替换背景颜色
    return window.innerWidth < 800 ? transformed : css;
}
```
在index.js中引入css文件即可：
```js
import style from './style/index.css';
```
打开控制台，如下图所示，当屏幕宽度小于`800`时候，`css`中的`yellow`已经被替换为了`green`。
<img :src="$withBase('/webpack4/css-loader4.png')" alt="">

::: warning
需要注意的是：transform是在`css`引入前根据需要修改，所以之后是不会改变的。所以上方代码不是响应式，当把屏幕宽度拉长到大于`800`时候，依旧是绿色。重新刷新页面，才会是黄色。
:::
## css打包处理
```js
yarn add style-loader css-loader -D
```
```js
// index.js
import avatar from './avatar.jpg';
import './index.css';

const img = new Image();
img.src = avatar;
img.classList.add('avatar');

document.body.appendChild(img);
```
```js
// index.css
@import './avatar.css';
```
```js
// avatar.css
.avatar {
    width: 100px;
    height: 100px;
    border-radius: 5px;
}
```
在上述代码中，在index.js中引入了index.css，在index.css中通过@import语法引入了avatar.css。页面展示效果如下：
<img :src="$withBase('/webpack4/css-loader6.png')" alt="">

从上面例子中，可以知道：
* css-loader：会分析多个css文件之间的关系(@import语法等)，把多个css文件合并成一段css代码。
* style-loader：将合并后的css插入到html文件head标签下的style标签中。
## less打包处理
```bash
yarn add less less-loader style-loader css-loader -D
# 样式添加前缀
yarn add postcss-loader autoprefixer -D
```
```js
// index.js
import avatar from './avatar.jpg';
import './index.less';

const img = new Image();
img.src = avatar;
img.classList.add('avatar');

document.body.appendChild(img);
```
```js
// index.less
.avatar {
    width: 100px;
    height: 100px;
    border-radius: 5px;
    transform: translate(100px, 200px);
}
```
```js
// postcss.config.js
module.exports = {
    plugins: [
        require('autoprefixer')
    ]
};
```
```js
{
    test: /\.less$/,
    // less-loader会将less语法转化为css语法
    // css-loader会分析多个css文件之间的关系(@import语法等)，把多个css文件合并成一段css代码
    // style-loader将合并后的css插入到html文件的style标签中
    use: [
        'style-loader',
        'css-loader',
        'less-loader',
        'postcss-loader'
    ]
}
```
<img :src="$withBase('/webpack4/css-loader7.png')" alt="">

### autoprefixer对@import方式引用css文件无效的解决方案
具体解决方案是配置importLoaders，[具体参考](https://www.jianshu.com/p/0f55bd17f64f)。
```js
// index.less
@import './avatar.less';
```
```js
// avatar.less
.avatar {
    width: 100px;
    height: 100px;
    border-radius: 5px;
    transform: translate(100px, 200px);
}
```
我们在index.js中引入了index.less，又在index.less中通过`@import`语法引入了avatar.less。
::: warning
需要注意：在index.js中引入了index.less，index.less文件的loader处理顺序为：less-loader->postcss-loader->css-loader->style-loader。

而对于avatar.less，其loader处理顺序为：css-loader->style-loader。默认并不会被less-loader和postcss-loader处理。这是因为importLoaders默认值为0。我们在index.js中引入了index.less，又在index.less中引入了avatar.less(`@import './avatar.less';`)。如果不配置`importLoaders: 2`，那么avatar.less将不会被postcss-loader和less-loader处理。如果css-loader后面只有postcss-loader，则设置`importLoaders: 1`。
:::
```js
{
    test: /\.less$/,
    // less-loader会将less语法转化为css语法
    // css-loader会分析多个css文件之间的关系(@import语法等)，把多个css文件合并成一段css代码
    // style-loader将合并后的css插入到html文件的style标签中
    use: [
    'style-loader',
    {
        loader: 'css-loader',
        options: {
            importLoaders: 2
        }
    },
    'postcss-loader',
    'less-loader'
    ]
}
```
::: warning
此外还需要注意：postcss-loader必须在css-loader之后，less-loader之前，否则前缀也添加不成功。
:::
## CSS Module(CSS模块化)
CSS模块化主要用来解决不同文件样式的冲突问题，避免样式之间的相互影响。
```js
// createAvatar.js
import avatar from './avatar.jpg';

function createAvatar() {
    const img = new Image();
    img.src = avatar;
    // 给image标签添加一个avatar的类
    img.classList.add('avatar');
    document.body.appendChild(img);
}

export default createAvatar;
```
```js
// index.js
import avatar from './avatar.jpg';
import './index.less';
import createAvatar from './createAvatar';

createAvatar(); // 每运行一次，就会在页面中添加一张图片
const img = new Image();
img.src = avatar;
img.classList.add('avatar');

document.body.appendChild(img);
```
例如上述代码：我们在index.js中创建了一个Image对象并给其添加了一个avatar的类。与此同时，在createAvatar.js中也创建了一个Image对象并给其添加了一个avatar的类。在index.less中给avatar的类添加了一些样式，这个样式是全局的，会同时影响到index.js和createAvatar.js中两个图片的样式。结果如下：
<img :src="$withBase('/webpack4/css-module.png')" alt="">

但是上图中的结果有时候并不是我们所期望的，如何才能让avatar的类的样式称为一个局部样式呢？具体配置如下：
```js
{
    loader: 'css-loader',
    options: {
        importLoaders: 2,
        modules: true // 开启css模块化打包，使得引入的样式文件仅仅作用于当前的js文件，不会对其他文件中同名类造成影响
    }
}
```
```js
import avatar from './avatar.jpg';
import style from './index.less'; // index.less引入方式改变
import createAvatar from './createAvatar';

createAvatar(); // 每运行一次，就会在页面中添加一张图片
const img = new Image();
img.src = avatar;
img.classList.add(style.avatar); // 添加类的方式发生改变

document.body.appendChild(img);
```
重新打包，结果如下：
<img :src="$withBase('/webpack4/css-module2.png')" alt="">

从上图结果可以看出：createAvatar.js中的图片样式并没有受到影响，符合预期。如果想让其也拥有对应的样式，也需要在createAvatar.js进行如下配置：
```js
import avatar from './avatar.jpg';
import style from './index.less'; // 引入index.less

function createAvatar() {
    const img = new Image();
    img.src = avatar;
    // 给image标签添加一个avatar的类
    img.classList.add(style.avatar); // 基于style添加avatar类
    document.body.appendChild(img);
}

export default createAvatar;
```
## sass打包处理
配置类似于less，[具体参考](https://webpack.js.org/loaders/sass-loader/)。
## 样式公共变量的提取
```bash
yarn add style-resources-loader -D
```