---
title: 配置
---
## Entry(入口)
`entry`是配置模块的入口，可抽象成输入，`Webpack`执行构建的第一步将从入口开始，搜寻及递归解析出所有入口依赖的模块。
### Entry类型
>`Entry`类型可以是以下三种中的一种或者相互组合：

![3d53382859d103b72a0b34ae75b6da3c.png](evernotecid://AC85336C-B325-443E-8ED7-E6554790A944/appyinxiangcom/10797539/ENResource/p60)
### Chunk的名称
`Webpack`会为每个生成的`Chunk`取一个名称，`Chunk`的名称和`Entry`的配置有关：

1. 如果`entry`是一个`string或array`，就只会生成一个`Chunk`，这时`Chunk`的名称是`main`；
2. 如果`entry`是一个`object`，就可能会出现多个`Chunk`，这时`Chunk`的名称是`object`键值对中键的名称。

## Output(输出)
### filename
`output.filename`配置输出文件的名称，为`string`类型。如果只有一个输出文件，则可以将它写成静态不变的：
```js
filename: 'bundle.js'
```
## Resolve
`Webpack`在启动后会从配置的入口模块出发找出所有依赖的模块，`Resolve`配置`Webpack`如何寻找模块对应的文件。
### alias
`resolve.alias`配置项通过别名来将原来导入路径映射成一个新的导入路径。
```js
module.exports = {
  //...
  resolve: {
    alias: {
      Utilities: path.resolve(__dirname, 'src/utilities/'),
      Templates: path.resolve(__dirname, 'src/templates/')
    }
  }
};
```
```js
// 原来这样访问
import Utility from '../../utilities/utility';
// 现在可以这样访问了
import Utility from 'Utilities/utility';
```
### mainFields
有一些第三方模块会针对不同的环境提供几份代码。例如分别提供采用了ES5和ES6的两份代码，这两份代码的位置写在了`package.json`文件里，代码如下：
```js
{
    "jsnext:main": "es/index.js", // 采用ES6语法的代码入口文件
    "main": "src/index.js" // 采用ES5语法的代码入口文件
}
```
Webpack会根据mainFields的配置去决定优先采用哪份代码，mainFields默认如下：
```js
module.exports = {
  //...
  resolve: {
    mainFields: ['browser', 'main']
  }
};
```
Webpack会按照数组里的顺序在`package.json`文件里寻找，只会使用找到的第一个文件。假如我们想优先采用ES6的代码，则可以如下配置：
```js
mainFields: ['jsnext:main', 'browser', 'main']
```
### extensions
在导入语句没带文件后缀时，Webpack会自动带上后缀去尝试访问文件是否存在。`resolve.extensions`用于配置在尝试过程中用到的后缀列表，默认是：
```js
module.exports = {
  //...
  resolve: {
    extensions: ['.ts', '.js', '.json']
  }
};
```
>也就是说，当遇到`require('./data')`这样的导入语句时，Webpack会先寻找`./data.ts`文件，如果该文件不存在，就去寻找`./data.js`文件，如果该文件不存在，就去寻找`./data.json`文件，如果还是找不到，就报错。

### modules
`resolve.modules`配置Webpack去哪些目录下寻找第三方模块，默认只会去`node_modules`目录下寻找。有时项目里会有一些模块被其他模块大量依赖和导入，由于其他模块的位置不定，针对不同的文件都要计算被导入的模块文件的相对路径，这个路径有时会很长，就像`import '../../../components/button'`，这就可以利用`resolve.modules`配置项进行优化。假设那些大量被导入的模块都在`./src/components`目录下，则进行如下配置即可：
```js
resolve: {
    modules: ['./src/components', 'node_modules']
  }
```
>之后可以简单的通过`import 'button'`导入。

### descriptionFiles
`resolve.descriptionFiles`配置描述第三方模块的文件名称，默认为：`package.json`。
```js
module.exports = {
  //...
  resolve: {
    descriptionFiles: ['package.json']
  }
};
```
### enforceExtension
`resolve.enforceExtension`默认值为false，如果被配置为true，则所有导入语句都必须带文件后缀，例如设置之前`import './foo'`能正常工作，开启后就必须写成`import './foo.js'`。
```js
module.exports = {
  //...
  resolve: {
    enforceExtension: false
  }
};
```
### enforceModuleExtension
`resolve.enforceModuleExtension`和`resolve.enforceExtension`的作用类似，但是`enforceModuleExtension`只对`node_modules`下的模块生效。`enforceModuleExtension`通常搭配`enforceExtension`使用，在`enforceExtension: true`时，因为安装的第三方模块中大多数导入语句都没有带文件的后缀，所以这时候通过设置`enforceModuleExtension: false`来兼容第三方模块。
## 其他配置
### Target
`Target`配置项可以让Webpack构建出针对不同运行环境的代码。
![6dce3a03d834d0b06de15680b1221279.png](evernotecid://AC85336C-B325-443E-8ED7-E6554790A944/appyinxiangcom/10797539/ENResource/p61)
>在设置`target: 'node'`时，在源代码中导入Node.js原生模块的语句require('fs')将会保留，fs模块的内容不会被打包到Chunk中。

### Devtool
devtool配置Webpack如何生成Source Map，默认值是false，即不生成Source Map，若想为构建出的代码生成Source Map以方便调试，可以这样配置：
```js
module.export = {
    devtool: 'source-map'
}
```
### Watch and WatchOptions
`watch`配置项用来配置Webpack的监听模式，支持监听文件更新，在文件发生变化时重新编译。在使用Webpack时，监听模式默认是关闭的，打开需进行如下配置：
```js
module.exports = {
  //...
  watch: true
};
```
>在使用`DevServer`时，监听模式默认开启。除此之外，还提供了watchOptions配置项来更灵活地控制监听模式，具体配置如下：
```js
module.exports = {
  // 只有在开启监听模式时，watchOptions才有意义
  // 默认为false，也就是不开启
  watch: true,
  // 监听模式运行时的参数
  // 在开启监听模式时才有意义
  watchOptions: {
    // 不监听的文件或文件夹，支持正则匹配
    // 默认为空
    ignored: /node_modules/,
    // 监听到变化发生后等300ms再去执行动作，截流
    // 防止文件更新太快而导致重新编译频率太快。默认为300ms
    aggregateTimeout: 300,
    // 判断文件是否发生变化是通过不停地询问系统指定文件有没有变化实现的
    // 默认每秒询问1000次
    poll: 1000
  }
};
```
### externals
`Externals`用来告诉Webpack要构建的代码中使用了哪些不用被打包的模块，也就是说这些模板是外部环境提供的，Webpack在打包时可以忽略它们。
>有些Javascript运行环境可能内置了一些全局变量或者模块，例如：在HTML的HEAD标签通过以下代码引入jQuery：
```js
<script
  src="https://code.jquery.com/jquery-3.1.0.js"
  integrity="sha256-slogkvB1K3VOkzAI8QITxV3VzpOnkeNVsKvtkYLMjfk="
  crossorigin="anonymous">
</script>
```
>这时，全局变量jQuery就会被注入网页的Javascript运行环境里。

如果想在使用模块化的源代码里导入和使用jQuery，可能需要这样：
```js
import $ from 'jquery';

$('.my-element').animate(/* ... */);
```
>构建后我们会发现输出的Chunk里包含的jQuery库的内容，这导致jQuery库出现了两次，浪费加载流量，最好是Chunk里不会包含jQuery库的内容。

`Externals`配置项就是用于解决这个问题的。通过`Externals`可以告诉Webpack在Javascript运行环境中已经内置了哪些全局变量，不用将这些全局变量打包到代码中而是直接使用它们。具体配置如下：
```js
module.exports = {
  //...
  externals: {
    jquery: 'jQuery'
  }
};
```
### resolveLoader
`resolveLoader`配置项用来告诉Webpack如何去寻找Loader，因为在使用Loader时是通过其包名称去引用的，Webpack需要根据配置的Loader包名去找到Loader的实际代码，以调用Loader去处理源文件。默认配置如下：
```js
module.exports = {
  //...
  resolveLoader: {
    // 去哪个目录下寻找Loader
    modules: [ 'node_modules' ],
    // 入口文件的后缀
    extensions: [ '.js', '.json' ],
    // 指明入口文件位置的字段
    mainFields: [ 'loader', 'main' ]
  }
};
```