---
title: 入门
---
## 模块化
**模块化**是指将一个复杂的系统分解为多个模块以方便编码。

### CommonJS
`CommonJS`是一种被广泛使用的`javascript`模块化规范，其**核心思想**是：通过`require`方法来同步加载依赖的其他模块，通过`module.exports`导出需要暴露的接口。`CommonJS`规范的流行得益于`Node.js`采用了这种方式，后来这种方式被引入到了网页开发中。
```js
// 导入
const moduleA = require('./moduleA');
// 导出
module.exports = moduleA.someFunc;
```
>`CommonJS`的优点：

* 代码可复用于Node.js环境下并运行，例如做同构应用；
* 通过Npm发布的很多第三方模块都采用了`CommonJS`规范。

>`CommonJS`的缺点：这样的代码无法直接运行在浏览器环境下，必须通过工具转换成标准的ES5。

### AMD
`AMD`也是一种`javascript`模块化规范，与`CommonJS`最大的不同在于：它采用了异步的方式去加载依赖的模块。`AMD`规范主要用于解决针对浏览器环境的模块化问题，最具代表性的实现是`requirejs`。
```js
// 定义一个模块
define('module', ['dep'], function(dep) {
    return exports;
});
// 导入和使用
require(['module'], function(module) {
});
```
>`AMD`的优点：

1. 可在不转换代码的情况下直接在浏览器中运行；
2. 可异步加载依赖；
3. 可并行加载多个依赖；
4. 代码可运行在浏览器环境和Node.js环境下。
>`AMD`的缺点：在javascript运行环境没有原生支持AMD，需要先导入实现了`AMD`的库后才能正常使用。

### ES6模块化
ES6模块化是国际标准化组织ECMA提出的javascript模块化规范，它在语言层面上实现了模块化。浏览器厂商和Node.js都宣布要原生支持该规范，它将逐渐取代CommonJS和AMD规范，成为浏览器和服务器通用的模块化解决方案。
```js
// 导入
improt React, {Component} from 'react';
// 导出
export function hello() {};
export default {
 // ...
}
```
>`ES6`模块化虽然是终极模块化方案，但是它的缺点在于：目前无法直接运行在大部分javascript运行环境下，必须通过工具转换成标准的ES5后才能正常运行。

>从`Webpack 2`版本开始，Webpack已经内置了对ES6、CommonJS、AMD模块化语句的支持。

## 安装webpack到项目目录
```js
// 安装最新的稳定版本
npm i -D webpack webpack-cli
// 安装指定版本
npm i -D webpack@<version> webpack-cli@<version>
// 安装最新的体验版本
npm i -D webpack@beta webpack-cli@beta
```
>特别注意：一般不推荐全局安装`webpack`，原因是可防止不同的项目因依赖不同版本的webpack而导致冲突。

## 使用Loader
```js
// 安装loader
npm i -D style-loader css-loader
```
```js
module: {
    rules: [
        {
            test: /\.css$/,
            use: ['style-loader', 'css-loader?minimize']
        }
    ]
}
```

* use属性的值是一个由Loader名称组成的数组，Loader的执行顺序是由后到前的；
* 每个Loader都可以通过`URL querystring`的方式传入参数，例如上述代码中`'css-loader?minimize'`中的`minimiz`e就是告诉`css-loader`要开启css压缩。
>向loader传入属性的方式除了可以通过`URL querystring`实现，还可以通过`Object`实现，配置如下：
```js
module: {
    rules: [
        {
            test: /\.css$/,
            use: ['style-loader',
                {
                    loader: 'css-loader',
                    options: {
                        minimize: true
                    }
                }
            ]
        }
    ]
}
```

>`style-loader`的工作原理是：将css的内容用javascript里的字符串存储起来，在网页执行javascript时通过DOM操作，动态地向`HTML head`标签里插入`HTML style`标签。

## 使用Plugin
`Plugin`是用来扩展webpack功能的，通过在构建流程里注入钩子实现，为webpack带来了很大的灵活性。
```js
npm install --save-dev mini-css-extract-plugin
```
```js
const MiniCssExtractPlugin = require("mini-css-extract-plugin");
module.exports = {
  plugins: [
    new MiniCssExtractPlugin({
      // 指定提取出来的css文件的名称
      filename: "[name]_[contenthash:8].css"
    })
  ],
  module: {
    rules: [
      {
        test: /\.css$/,
        use: [
          MiniCssExtractPlugin.loader,
          "css-loader"
        ]
      }
    ]
  }
}
```
>`[name]`代表文件的名称，`[contenthash:8]`代表根据文件内容算出的8位Hash值。

## 使用DevServer
`DevServer`会启动一个HTTP服务器用于服务网页请求，同时会帮助启动Webpack，并接收Webpack发出的文件变更信号，通过WebSocket协议自动刷新网页做到实时预览。
```js
npm i -D webpack-dev-server
```
>需要注意的是：`DevServer`会将Webpack构建出的文件保存在内存中，在要访问输出的文件时，必须通过HTTP服务访问。

### 实时预览
Webpack在启动时可以开启监听模式，之后Webpack会监听本地文件系统的变化，在发生变化时重新构建出新的结果。Webpack默认关闭监听模式，我们可以在启动Webpack时通过`webpack --watch`来开启监听模式。
>通过`DevServer`启动的Webpack会开启监听模式，当发生变化时重新执行构建，然后通知`DevServer`。`DevServer`会让Webpack在构建出的javascript代码里注入一个代理客户端用于控制网页，网页和`DevServer`之间通过WebSocket协议通信，以方便`DevServer`主动向客户端发送命令。`DevServer`在收到来自Webpack的文件变化通知时，通过注入的客户端控制网页刷新。

>如果尝试修改`index.html`文件并保存，则我们会发现这并不会触发以上机制，导致这个问题的原因是：`Webpack`在启动时会以配置里的`entry`为入口去递归解析出`entry`所依赖的文件，只有`entry`本身和依赖的文件才会被`Webpack`添加到监听列表里。而`index.html`文件是脱离了`javascript`模块化系统的，所以`Webpack`不知道它的存在。

### 模块热替换

### 支持Source Map
```js
// 开启Source Map
devtool: 'cheap-module-source-map'
```
![5baba8f686490372c1e903d53b9be998.png](evernotecid://AC85336C-B325-443E-8ED7-E6554790A944/appyinxiangcom/10797539/ENResource/p59)
