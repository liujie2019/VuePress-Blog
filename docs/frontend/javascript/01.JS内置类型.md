---
title: 0. JS 内置变量类型
---
::: tip
写作不易，Star是最大鼓励，感觉写的不错的可以给个Star⭐，请多多指教。[欢迎访问](https://github.com/liujie2019/VuePress-Blog)。
:::
## 变量类型
JS中分为七种内置类型，按照**存储方式**划分变量类型又分为两大类型：基本类型(值类型)和引用类型(对象类型)。

* 基本类型有六种：
  * null
  * undefined
  * boolean: true/false
  * number: 任意的数字
  * string: 任意字符串
  * symbol(ES6)
* 引用类型包括：
  * 对象(Object): 任意对象，内部数据是无序的
  * 数组(Array): 一种带数值下标的特别对象，内部数据是有序的
  * 函数(Function): 一种特别的对象(可以执行)

基本类型分别在内存中**占有固定的大小空间**，它们的值保存在**栈空间**，我们通过**按值**来访问的。
**引用类型的值**，则必须在**堆内存**中为这个值分配空间。由于引用类型值的**大小不固定**（对象有很多属性和方法，而且还可以动态的添加属性和方法），因此不能把他们保存到栈内存中。但**内存地址大小是固定的**，因此可以**将内存地址保存在栈内存中**。

**简而言之：** 栈内存中存放的是基本数据类型值，堆内存中存放的是引用类型值，引用类型值在内存中的地址存放在栈中，也就是我们常说的对象对象引用(指针)。
![这里写图片描述](http://img.blog.csdn.net/20160809100356773)

其中JS的数字类型是浮点类型的，没有整型。并且浮点类型基于IEEE 754标准实现，在使用中会遇到某些Bug。**NaN也属于number类型**，并且NaN不等于自身(ES5)。

>需要注意：ES6中Object.is(NaN, NaN); // true

对于基本类型来说，如果使用字面量的方式，那么这个变量只是个字面量，只有在必要的时候才会转换为对应的类型
```js
let a = 111 // 这只是字面量，不是number类型
a.toString() // 使用时候才会转换为对象类型
```
对象是引用类型，在使用过程中会遇到浅拷贝和深拷贝的问题。
```js
let a = { name: 'FE' }
let b = a
b.name = 'EF'
console.log(a.name) // EF
```
```js
// 值类型
var a = 100;
var b = a;
a = 200;
console.log(b); // 100
```
![fa97ae3016949aa54c3cce9fa70957ec.png](evernotecid://AC85336C-B325-443E-8ED7-E6554790A944/appyinxiangcom/10797539/ENResource/p1161)

>a和b指向了内存空间中的同一区域。引用类型包括：对象、数组和函数等。为什么要这样设计呢？因为，加入a对象有很多属性(占用内存多)，又将a赋值给b，b也会占用很多内存空间，为了使得内存空间可以公用，设计了引用类型赋值指向同一内存区域。

![c27c8f809869f9911fdba9e1dc35ec92.png](evernotecid://AC85336C-B325-443E-8ED7-E6554790A944/appyinxiangcom/10797539/ENResource/p1162)
![6795a283400a014ff70965c1ba934275.png](evernotecid://AC85336C-B325-443E-8ED7-E6554790A944/appyinxiangcom/10797539/ENResource/p1163)

>需要注意：不仅对象可以有属性，数组和函数也可以有属性，都是公用内存空间。
### 变量复制
```js
var a = 5;
var b = a;
console.log(a+"---"+b); // 5---5
b = 6; // 这里重新给b赋值，a值并没有改变
console.log(a+"---"+b); // 5---6

var obj = {name:"lisi"};
var obj2 = obj; // 这里是引用赋值，obj和obj2指向同一个对象
console.log(obj.name + "---" + obj2.name); // lisi---lisi
obj2.name = "wangwu";
console.log(obj.name + "---" + obj2.name); // wangwu---wangwu
```
从上面例子可以看出：在变量复制方面，基本类型和引用类型也有所不同，基本类型复制的是**值本身**，而引用类型复制的是内存地址。
### undefined和null的区别
* undefined：表示变量定义了但未赋值；
* null：变量定义了且值是null。

### 什么时候使用null？
* 给对象初始赋值，表示将要赋值为对象；
* 让对象成为垃圾对象，被垃圾回收器回收

### 严格区别变量类型与数据类型
* 数据类型
  * 基本类型
  * 对象类型

* 变量类型(变量内存值的类型)
  * 基本类型变量：保存的是基本类型的数据值；
  * 引用类型变量：保存的是地址。
## 数据类型判断
### typeof(返回字符串)
typeof对于基本类型，除了null都可以显示正确的类型。typeof返回的是数据类型的字符串表达。
```js
typeof 1 // 'number'
typeof 'abc' // 'string'
typeof undefined // 'undefined'
typeof true // 'boolean'
typeof Symbol() // 'symbol'
typeof a // 'undefined' a虽然没有声明，但是还会显示undefined
```
typeof对于引用类型，除了函数都会显示object。
```js
typeof [] // 'object'
typeof {} // 'object'
typeof console.log // 'function'
```
```js
typeof NaN  // number
typeof undefined // undefined
typeof null // null
typeof function fn(){} // "function"
// Object和Number都是构造函数
typeof Object // "function"
typeof Number // "function"
```
::: warning
特别注意：对于null来说，虽然它是基本类型，但是会显示object。`typeof null === 'object'`。所以，typeof只能用来判断除了null以外的基本数据类型，无法判断null和(Object)引用类型。
:::
### instanceof(判断对象的具体类型)
```js
// instanceof左边是实例对象，右边是实例对象的构造函数
// 判断给定实例是不是构造函数的实例对象
实例 instanceof 构造函数

const obj = {
    arr: [123, 'test', console.log],
    fn: function() {
        console.log('111');
    }
}

console.log(obj instanceof Object, obj instanceof Array); // true false
console.log(obj.arr instanceof Array, obj.arr instanceof Object); // true true
console.log(obj.fn instanceof Function, obj.fn instanceof Object); // true true

console.log(typeof obj.fn); // 'function'
console.log(typeof obj.arr); // 'object'
```
### 如何获取一个变量的正确类型
如果想获得一个变量的正确类型，可以通过 `Object.prototype.toString.call(xx)`。这样我们就可以获得类似`[object Type]`的字符串。

```js
Object.prototype.toString.call(12); // "[object Number]"
Object.prototype.toString.call({name: 'lisi'}); // "[object Object]"
Object.prototype.toString.call(null); // "[object Null]"
// 对于未声明的变量
Object.prototype.toString.call(a); // "[object Undefined]"
Object.prototype.toString.call(NaN); // "[object Number]"
```
## 强制类型转换
>强制类型转换场景：

* 字符串拼接
* ==运算符
* if语句
* 逻辑运算符
* 三元运算符

```js
// 字符串拼接
console.log(100 + 10); // 110
console.log(100 + '10'); // '10010'
console.log(100 - '10'); // 90
```
```js
// ==运算符(慎用)
// 数字100会转换为字符串'100'
console.log(100 == '100'); // true
// 0和''都会转换为false
console.log(0 == ''); // true
// null和undefined都会转换为false
console.log(null == undefined); // true
```
![d71a3616b15cdf16789fe64a14dfd6fe.png](evernotecid://AC85336C-B325-443E-8ED7-E6554790A944/appyinxiangcom/10797539/ENResource/p1166)
### 转Boolean
在条件判断时，除了undefined，null，false，NaN， ''，0，-0，其他所有值都转为true，包括所有对象。

![e66930f118ca1a1a8b00621f65cdfb02.png](evernotecid://AC85336C-B325-443E-8ED7-E6554790A944/appyinxiangcom/10797539/ENResource/p1167)
```js
// 逻辑运算符
console.log(100 && 0); // 0
```
### 对象转基本类型
对象在转换基本类型时，首先会调用 valueOf 然后调用 toString。并且这两个方法你是可以重写的。
```js
let a = {
    valueOf() {
    	return 0
    }
}
```
当然也可以重写Symbol.toPrimitive，该方法在转基本类型时调用优先级最高。
```js
let a = {
  valueOf() {
    return 0;
  },
  toString() {
    return '1';
  },
  [Symbol.toPrimitive]() {
    return 2;
  }
}
1 + a // => 3
'1' + a // => '12'
```
### 四则运算符
只有当加法运算时，其中一方是字符串类型，就会把另一个也转为字符串类型。其他运算只要其中一方是数字，那么另一方就转为数字。并且加法运算会触发三种类型转换：将值转换为原始值，转换为数字，转换为字符串。
```js
1 + '1' // '11'
2 * '2' // 4
[1, 2] + [2, 1] // '1,22,1'
// [1, 2].toString() -> '1,2'
// [2, 1].toString() -> '2,1'
// '1,2' + '2,1' = '1,22,1'
```
对于加号需要注意这个表达式 'a' + + 'b'
```js
'a' + + 'b' // -> "aNaN"
// 因为 + 'b' -> NaN
// 你也许在一些代码中看到过 + '1' -> 1
```
### == 操作符
![1a0c6739b68861b525c0aec239a79c5f.png](evernotecid://AC85336C-B325-443E-8ED7-E6554790A944/appyinxiangcom/10797539/ENResource/p1170)
上图中的toPrimitive就是对象转基本类型。

这里来解析一道题目`[] == ![] // -> true`，下面是这个表达式为何为true的步骤：
```js
// [] 转成 true，然后取反变成 false
[] == false
// 根据第 8 条得出
[] == ToNumber(false)
[] == 0
// 根据第 10 条得出
ToPrimitive([]) == 0
// [].toString() -> ''
'' == 0
// 根据第 6 条得出
0 == 0 // -> true
```
### 比较运算符

* 如果是对象，就通过 toPrimitive 转换对象；
* 如果是字符串，就通过 unicode 字符索引来比较

## 何时使用===何时使用==
```js
if (obj == null) {
    // 这里相当于 obj === null || obj === undefined 的简写形式
    // 这是jQuery源码中的推荐写法
}
```
>只有在判断变量是否为null或者undefined的时候用`==`，其他情况一律用`===`。

* `==`会发生强制类型转换，`===`不会。

### ES6中Object.is
<Valine></Valine>