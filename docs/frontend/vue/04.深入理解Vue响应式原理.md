---
title: 4. 深入理解Vue响应式原理
---
[TOC]
::: tip
写作不易，Star是最大鼓励，感觉写的不错的可以给个Star⭐，请多多指教。[本博客的Github地址](https://github.com/liujie2019/VuePress-Blog)。
:::

## 响应式理解
当js对象中的数据发生改变的时候，与js对象中数据相关联的DOM视图也会进行更新(即所谓的数据驱动视图)。
## 响应式实现思路
想要实现响应式，需要做如下事情：
1. 监听对象数据的变化。
2. 收集视图依赖了哪些数据(依赖收集)。
3. 数据变化时，自动通知和数据相关联的视图页面，并对视图进行更新。

1. 利用Proxy或Object.defineProperty生成的Observer针对对象/对象的属性进行"劫持"，在属性发生变化后通知订阅者；
2. 解析器Compiler解析模板中的Directive(指令)，收集指令所依赖的方法和数据，等待数据变化然后进行渲染；
3. Watcher属于Observer和Compile桥梁，它将接收到的Observer产生的数据变化，并根据Compiler提供的指令进行视图渲染，使得数据变化促使视图变化。
### 如何监听对象数据的变化？
对象数据监听也叫做**数据劫持**，Vue采用**数据劫持及发布者-订阅者模式**，通过Object.defineProperty来劫持各个属性的setter，getter。在数据变化时发送消息给订阅者，触发相应的监听回调。当然也可以使用ES6中的Proxy来对各个属性进行代理(推荐)。
## 响应式代码实现
在ES5中，新增了Object.defineProperty这个API，允许我们为对象的属性设定getter和setter。我们可以使用该API对该对象的属性值获取或设置进行劫持。
```js
// Vue2.0如何实现响应式原理
// 数据变化了，可以更新视图
function observer(target) {
    // 判断target是否为对象
    if (typeof target !== 'object' || target == null) {
        return target;
    }
    for (const key in target) {
        if (target.hasOwnProperty(key)) {
            // 定义响应式
            defineReactive(target, key, target[key]);
        }
    }
}

function defineReactive(target, key, value) {
    Object.defineProperty(target, key, {
        get() {
            return value;
        },
        set(newValue) {
            if (newValue !== value) {
                updateView();
                value = newValue;
            }
        }
    });
}

function updateView() {
    console.log('数据更新了');
}

// 只是一层
const person = {name: 'kobe'};
observer(person);
person.name = 'james';
console.log(person.name);
```
注意点1：针对key的value也是对象的情况(需要递归进行绑定)。
```js
// Vue2.0如何实现响应式原理
// 数据变化了，可以更新视图
function observer(target) {
    if (typeof target !== 'object' || target == null) {
        return target;
    }
    for (const key in target) {
        if (target.hasOwnProperty(key)) {
            defineReactive(target, key, target[key]);
        }
    }
}

function defineReactive(target, key, value) {
    // 注意点1：针对key的value是对象的情况，递归遍历子对象
    observer(value);
    Object.defineProperty(target, key, {
        get() {
            return value;
        },
        set(newValue) {
            if (newValue !== value) {
                updateView();
                value = newValue;
            }
        }
    });
}

function updateView() {
    console.log('数据更新了');
}

const person = {name: 'kobe', age: {value: 12}};
observer(person);
// person.name = 'james';
person.age.value = 14;
console.log(person.age.value);
```
注意点2：针对给key**重新赋值**的value是对象的情况。
```js
// Vue2.0如何实现响应式原理
// 数据变化了，可以更新视图
function observer(target) {
    if (typeof target !== 'object' || target == null) {
        return target;
    }
    for (const key in target) {
        if (target.hasOwnProperty(key)) {
            defineReactive(target, key, target[key]);
        }
    }
}

function defineReactive(target, key, value) {
    // 注意点1：针对key的value是对象的情况，递归
    observer(value);
    Object.defineProperty(target, key, {
        get() {
            return value;
        },
        set(newValue) {
            // 注意点2：针对给key重新赋值的value是对象的情况，如果新值是对象的话，递归该对象进行监听
            observer(newValue);
            if (newValue !== value) {
                updateView();
                value = newValue;
            }
        }
    });
}

function updateView() {
    console.log('数据更新了');
}

const person = {name: 'kobe', age: {value: 12}};
observer(person);
person.age = {value: 13};
person.age.value = 16;
// 应该输出两次'数据更新了'，因为age和value都是响应式的
console.log(person.age.value);
```
![](https://github.com/liujie2019/static_data/blob/master/img/20200105120128.png?raw=true)

## Object.defineProperty的缺陷
问题：
1. 对于对象新增的属性将不会是响应式的
2. 不支持属性值是数组的情况
## 实现数组劫持
```js
// Vue2.0如何实现响应式原理
// 数据变化了，可以更新视图
const oldArrayPrototype = Array.prototype;
const proto = Object.create(oldArrayPrototype); // 继承数组原型的方法
['push', 'shift', 'unshift'].forEach(method => {
    // 函数劫持，把函数进行重写，内部继续调用老的数组方法
    proto[method] = function() {
        updateView(); // 面向切片编程
        oldArrayPrototype[method].call(this, ...arguments);
    }
});
function observer(target) {
    if (typeof target !== 'object' || target == null) {
        return target;
    }
    if (Array.isArray(target)) { // 拦截数组，将数组的方法进行重写
        Object.setPrototypeOf(target, proto);
        // target.__proto__ = proto;
    }
    for (const key in target) {
        if (target.hasOwnProperty(key)) {
            defineReactive(target, key, target[key]);
        }
    }
}

function defineReactive(target, key, value) {
    // 注意点1：针对key的value是对象的情况，递归
    observer(value);
    Object.defineProperty(target, key, {
        get() { // get中进行依赖收集
            return value;
        },
        set(newValue) {
            // 注意点2：针对给key重新赋值的value是对象的情况
            observer(newValue);
            if (newValue !== value) {
                updateView();
                value = newValue;
            }
        }
    });
}

function updateView() {
    console.log('数据更新了');
}

const person = {name: 'kobe', hobbies: ['🏀', '⚽️']};
observer(person);
person.hobbies.push('🏉'); // 需要对数组的方法进行重写
```
## 使用Proxy来实现数据劫持
Object.defineProperty方法存在如下缺点：
1. 监听数组的方法不能触发Object.defineProperty方法中set操作(如果我们需要监听的话，我们需要重写数组的方法)。
2. 必须遍历每个对象的每个属性，如果对象嵌套比较深的话，我们需要递归调用。
3.
## 参考文档
1. [深入理解Vue响应式原理](https://funteas.com/topic/5a809f5847dc830a0e4690c2)
2. [vue系列---响应式原理实现及Observer源码解析(七)](https://www.cnblogs.com/tugenhua0707/p/11754291.html)
3. [深入理解 Object.defineProperty 及实现数据双向绑定](https://www.cnblogs.com/tugenhua0707/p/10261170.html)