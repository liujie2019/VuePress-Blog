---
title: 1. React dom-diff算法
---
::: tip
写作不易，Star是最大鼓励，感觉写的不错的可以给个Star⭐，请多多指教。[本博客的Github地址](https://github.com/liujie2019/VuePress-Blog)。
:::
## 虚拟DOM
Virtual DOM，顾名思义就是虚拟节点。主要通过JS中的对象来模拟DOM中的节点，然后再通过render方法将其渲染成真实的DOM节点。
### 虚拟DOM实现
```js
├── README.md
├── package.json
├── public
│   ├── favicon.ico
│   ├── index.html // 项目入口
│   ├── logo192.png
│   ├── logo512.png
│   ├── manifest.json
│   └── robots.txt
├── src
│   ├── diff.js
│   ├── element.js
│   ├── index.js // 主入口文件
│   └── patch.js
└── yarn.lock
```
上述项目目录结构是采用create-react-app脚手架直接生成的，目的是为了方便代码编译调试。
```js
// 全局安装
yarn global add create-react-app
// 生成项目
create-react-app dom-diff
// 进入项目目录
cd dom-diff
// 启动项目
yarn run start
```
### 创建虚拟DOM
在element.js文件中主要实现如何创建虚拟DOM以及将创建出来的虚拟DOM渲染成真实的DOM。

代码如下：
```js
// element.js
// 虚拟DOM元素的类
class Element {
    constructor(type, props, children) {
        // 将参数挂载到实例的私有属性上
        this.type = type;
        this.props = props;
        this.children = children;
    }
}
// 创建虚拟dom节点，返回object
function createElement(type, props, children) {
    return new Element(type, props, children);
}

export {
    Element,
    createElement
}
```
在入口文件index.js里调用createElement方法来生成虚拟dom：
```js
// index.js

// 首先引入对应的方法来创建虚拟DOM
import { createElement } from './element';

const virtualDom = createElement('ul', {class: 'list'}, [
    createElement('li', {class: 'item'}, ['科比']),
    createElement('li', {class: 'item'}, ['詹姆斯']),
    createElement('li', {class: 'item'}, ['罗斯'])
]);

console.log(virtualDom);
```
在Vue和React中用来创建虚拟DOM的方法也叫createElement。这里createElement方法接收三个参数，分别是type，props和children。

* type: 指定dom元素的标签类型，如'ul'、'li'、'div'等；
* props: 表示dom元素的属性，如class、style或者自定义属性；
* children: 表示dom元素的子节点，元素可以拥有多个子节点，所以是一个数组。

生成的虚拟DOM如下图所示：

<img :src="$withBase('/react/dom-diff.png')" alt="">

### 渲染虚拟DOM
```js
// element.js
class Element {
    // 省略 同上文
}

function createElement() {
    // 省略 同上文
}
/**
 * 给DOM元素设置属性
 * @param  {any} node 当前dom元素
 * @param  {any} key 属性名称
 * @param  {any} value 属性值
 * @return {void}
 */
function setAttr(node, key, value) {
    switch (key) {
        // key是value的情况，需要判断是否为输入框
        case 'value': // node是一个input或者textarea
            if(node.tagName.toUpperCase() === 'INPUT' || node.tagName.toUpperCase() === 'TEXTAREA') {
                node.value = value;
            } else { // 其他情况直接调用setAttribute
                node.setAttribute(key, value);
            }
            break;
        case 'style':
            node.style.cssText = value; // 设置行内样式
            break;
        default: // 默认为普通属性，直接调用setAttribute赋值即可
            node.setAttribute(key, value);
            break;
    }
}
// render方法可以将vnode转化为真实dom
function render(eleObj) {
    const {type, props, children} = eleObj;
    // 调用createElement创建dom元素
    const el = document.createElement(type);
    for (let key in props) {
        // 给当前dom元素设置属性
        setAttr(el, key, props[key]);
    }
    // 遍历子节点，如果是虚拟dom继续渲染，不是就代表的是文本节点
    children.forEach(child => {
        // 判断当前子节点是否Element类型，是的话则为虚拟DOM节点，递归调用render方法渲染，否则返回一个文本节点
        child = (child instanceof Element) ? render(child) : document.createTextNode(child);
        el.appendChild(child);
    });
    return el;
}
// 将元素插入页面中
function renderDom(el, target) {
    target.appendChild(el);
}

export {
    Element,
    createElement,
    render,
    setAttr,
    renderDom
};
```
再次回到index.js文件中，调用render方法，代码如下：
```js
import {
    createElement, // 创建虚拟DOM方法
    render,
    renderDom
} from './element';

const virtualDom = createElement('ul', {class: 'list'}, [
    createElement('li', {class: 'item'}, ['科比']),
    createElement('li', {class: 'item'}, ['詹姆斯']),
    createElement('li', {class: 'item'}, ['罗斯'])
]);

// console.log(virtualDom);
const el = render(virtualDom); // 将虚拟dom转化为了真实的dom
// console.log(el);
// window.root与document.querySelector('#root')等价
// 将渲染真实的dom添加到页面中
renderDom(el, window.root);
```
<img :src="$withBase('/react/dom-diff2.png')" alt="">

## 差异计算
![9004597f093e928bd6eb0d29f5e19d01.png](evernotecid://AC85336C-B325-443E-8ED7-E6554790A944/appyinxiangcom/10797539/ENResource/p919)

![7a5d79f492c6d0be1f5bf80f9ccecf82.png](evernotecid://AC85336C-B325-443E-8ED7-E6554790A944/appyinxiangcom/10797539/ENResource/p920)
## DOM diff
DOM diff是比较两个虚拟DOM区别，比较两个对象的区别。
DOM diff是通过js层面的计算，返回一个patch对象，即补丁对象。再通过特定的操作解析patch对象，完成页面的重新渲染。
Dom diff的作用：根据两个虚拟对象创建出补丁，描述改变的内容，将这个补丁用来更新dom。
![bd98930ba8ead15eaf598bcf9503c843.png](evernotecid://AC85336C-B325-443E-8ED7-E6554790A944/appyinxiangcom/10797539/ENResource/p914)

## diff算法原理
React将VirtualDOM树转换为actualDOM的最少操作过程称为调和（reconciliation）。

diff算法就是调和过程的具体实现。需要特别注意：render 执行的结果得到的不是真正的 DOM 节点。
结果仅仅是轻量级的 JavaScript 对象, 我们称之为 `virtual DOM`。

## diff策略

1. Web UI 中DOM节点跨层级的移动操作很少，忽略不计；
2. 拥有相同类的两个组件将会生成相似的树形结构，拥有不同类的两个组件将会生成不同的树形结构；
3. 对于同一个层级的一组子节点，可以通过它们唯一的ID来进行区分。

### tree diff(只对相同层级的DOM节点进行比较)
![c292d863be4573743d9a163e7ea9249b.png](evernotecid://AC85336C-B325-443E-8ED7-E6554790A944/appyinxiangcom/10797539/ENResource/p916)

基于策略1：React对树的算法进行了简洁明了的优化。只对树进行分层比较，两棵树只会对同一层次的节点进行比较。

React**只会对相同层级的DOM节点进行比较**，即同一个父节点下的所有子节点，当发现该节点已经不存在了，就会删除该节点和其所有子节点，不会再做进一步的比较。

**而如果真的出现了跨层级的移动，并不会出现移动操作，而是被移动的根节点被删除后重新创建**。

### component diff
![10c1905667b82d0e79a9c277677620e2.png](evernotecid://AC85336C-B325-443E-8ED7-E6554790A944/appyinxiangcom/10797539/ENResource/p917)
>上述图中，左边的根节点有A节点，右边的根节点没有A节点，在比较后，会直接删除A节点及其子节点B和C，在M节点下方重新生成A节点及其子节点B和C。

组件之间的比较策略：

* 如果是同一类型的组件，按原策略继续比较Virtual DOM树即可；
* 如果不是，则将该组件判断为dirty component，从而替换整个组件下的所有子节点；
* 对于同一类型的组件，可能其virtual DOM没有任何变化，如果能确切的知道这一点，那么就可以节省大量的diff运算时间。因此，React允许用户通过`shouldComponentUpdate()`来判断是否需要对组件进行diff算法分析。
### element diff
![a3993342fcd2ea53cb9110f51cfe9e55.png](evernotecid://AC85336C-B325-443E-8ED7-E6554790A944/appyinxiangcom/10797539/ENResource/p918)
>通过key来实现节点的移动。

当节点处于同一个层级的时候，diff提供了三种节点操作：INSERT_MARKUP(插入)、MOVE_EXISTING(移动)、REMOVE_NODE(删除)。

* 插入：新的组件不在旧的集合里，也就是是一个全新的节点；
* 旧集合中有新的组件类型，且element是可更新的类型，generateComponent-Children已经调用receiveComponent，这种情况下prevChild=nextChild，就需要做移动操作，可以复用以前的DOM节点；
* 旧组件类型，在新集合里也有，但对应的element不同则不能直接复用和更新，需要执行删除操作。或者旧组件不在新集合里，也要执行删除操作。

通过key发现新老集合中的节点都是相同的节点，因此无需进行节点删除和创建，只需要将老集合中节点的位置进行移动，更新为新集合中节点的位置。

## 总结
1. React通过制定大胆的diff策略，将O(n3)复杂度的问题转换成 O(n)复杂度的问题；
2. React通过分层求异的策略，对tree diff进行算法优化；
3. React通过相同类生成相似树形结构，不同类生成不同树形结构的策略，对component diff进行算法优化；
4. React通过设置唯一key的策略，对element diff进行算法优化；
5. 建议在开发组件时，保持稳定的DOM结构会有助于性能的提升；
6. 建议在开发过程中，尽量减少类似将最后一个节点移动到列表首部的操作，当节点数量过大或更新操作过于频繁时，在一定程度上会影响React的渲染性能。

## 参考文档

1. [https://user-gold-cdn.xitu.io/2019/8/1/16c49afec13e0416](https://user-gold-cdn.xitu.io/2019/8/1/16c49afec13e0416)
2. [React 源码剖析系列 － 不可思议的 react diff](https://zhuanlan.zhihu.com/p/20346379)
2. [浅谈React中的diff](https://juejin.im/post/5ac355576fb9a028cc616aad)
3. [React源码分析 - Diff算法](https://juejin.im/post/5aa163df518825557b4c4f0a)
4. [虚拟DOM Diff算法解析](https://www.kancloud.cn/kancloud/react-in-depth/67091)
5. [深入框架本源系列 —— Virtual Dom ](https://github.com/KieSun/Dream/issues/5)