---
title: 10. 深拷贝和浅拷贝
---
::: tip
写作不易，Star是最大鼓励，感觉写的不错的可以给个Star⭐，请多多指教。[Github地址](https://github.com/liujie2019/VuePress-Blog)。
:::
首先说明下：深拷贝和浅拷贝都是针对引用数据类型的。

## js数据类型
1. 数据分为基本的数据类型(String，Number，Boolean，null，undefined)和引用数据类型。
2. 基本数据类型特点：存储的是实际数据，存储在**栈内存**中。
3. 引用数据类型特点：存储的是该对象在栈中引用(存储的是对象的地址值)，真实的数据存放在**堆内存**中。

对基本数据类型进行拷贝操作会对值进行一份拷贝，而对引用类型赋值，则会进行地址的拷贝，最终两个变量指向同一份数据。
堆内存用于存放由`new`创建的对象，栈内存存放一些基本类型的变量和对象的引用变量。

::: tip
深拷贝和浅拷贝最根本的区别在于：是否是真正获取了一个对象的复制实体，而不是引用。浅拷贝就是只进行一层拷贝，深拷贝就是无限层级拷贝。
:::
1. **深拷贝**会在计算机中开辟了一块新的内存地址用于存放复制的对象；
2. 而浅拷贝仅仅是指向被复制的内存地址，如果原地址中对象被改变了，那么浅拷贝的对象也会相应改变。

要实现深拷贝，需要先了解js数据类型：   

1. 基本类型: Undefined、Null、Boolean、Number、String、Symbol；
2. 引用类型: Object。

## 基本数据类型拷贝
```js
// 基本数据类型存放的就是实际的数据，可以直接拷贝
let a = 10;
let b = a; // 将变量a的值赋值给变量b
a = 100; // 变量a的改变后，不会影响到变量b
console.log(a); // 100
console.log(b); // 10
```
## 引用数据类型拷贝
```js
let obj1 = {
	name: 'lisi',
	age: '22'
};
let obj2 = obj1; // obj2复制的是obj1在栈内存的引用(即obj1的地址值)
obj2.age = 23;
console.log(obj1.age); // 23
console.log(obj2.age); // 23
```
上述代码只是将obj1对象的**引用地址**赋值给了obj2对象。即两者都指向了同一块**堆内存空间**(同一个对象)，所以其中一个发生变化也会导致另外一个变化。
### 区分引用数据类型的浅拷贝和深度拷贝
判断依据：拷贝是否产生了新的数据(即是否在堆内存中重新开辟了一块内存空间)还是拷贝的是数据的引用(对象数据存放的是对象在栈内存的引用，直接复制的是对象的引用)。

## 引用类型浅拷贝
常用拷贝技术：
1. arr.concat(): 数组浅拷贝
2. arr.slice(): 数组浅拷贝
3. JSON.parse(JSON.stringify(arr/obj)): 数组或对象深拷贝，但不能处理函数数据
4. Object.assign(target, source)
### concat和slice
```js
/**
 * concat和slice可以实现数据的浅拷贝
 * 数组的元素都是基本数据类型
 */
const arr = ['test', 1, true, null, undefined];
const arr_new = arr.concat(); // 实现数组的浅拷贝
const arr_slice = arr.slice();
arr_new[1] = 2;
arr_slice[1] = 3;
// [ 'test', 1, true, null, undefined ] [ 'test', 2, true, null, undefined ] [ 'test', 3, true, null, undefined ]
console.log(arr, arr_new, arr_slice);
```
### 数组中嵌套了对象或者数据
```js
/**
 * 数组中嵌套了对象或者数据
 */
const arr = [{name: 'lisi'}, [1, 2, 3]];
const arr_new = arr.concat(); // 实现数组的浅拷贝
// const arr_new = Array.from(arr);
arr[0].name = 'lisi-from';
arr[1][0] = 222;
// [ { name: 'lisi-from' }, [ 222, 2, 3 ] ] [ { name: 'lisi-from' }, [ 222, 2, 3 ] ]
console.log(arr, arr_new);
// 无论是新数组还是旧数组都发生了变化，也就是说使用concat方法实现的是浅拷贝
```
对于数组复制，ES6有新的两种方法，不会发生引用。

### Array.from
```js
var arr = [2, 3, 4];
var arr2 = Array.from(arr);
arr.push(5);
console.log(arr); // [2, 3, 4, 5]
console.log(arr2); // [2, 3, 4]
arr2.push(6);
console.log(arr); // [2, 3, 4, 5]
console.log(arr2); // [2, 3, 4, 6]
```
### 扩展运算符(...)
```js
var arr = [2, 3, 4];
var arr2 = [...arr];
arr.push(5);
console.log(arr); // [2, 3, 4, 5]
console.log(arr2); // [2, 3, 4]

arr2.push(6);
console.log(arr); // [2, 3, 4, 5]
console.log(arr2); // [2, 3, 4, 6]
```
### 循环拷贝
```js
var arr = [2, 3, 4];
var arr2 = [];
for(let i of arr) {
	arr2.push(i);
}
arr.push(5);
arr2.push(6);
console.log(arr);//[2, 3, 4, 5]
console.log(arr2);//[2, 3, 4, 6]

// 如果是对象
var obj1 = {
	name: 'lisi',
	age: 22
};
var obj2 = {};
for(let key in obj1) {
	obj2[key] = obj1[key];
}
console.log(JSON.stringify(obj1));
// {"name":"lisi","age":22}
console.log(JSON.stringify(obj2));
// {"name":"lisi","age":22}
obj1.job = 'worker';
obj2.job = 'teacher';
console.log(JSON.stringify(obj1));
// {"name":"lisi","age":22,"job":"worker"}
console.log(JSON.stringify(obj2));
// {"name":"lisi","age":22,"job":"teacher"}
```
```js
// 上述方法也可以用来接收函数参数
function show(...arr){ // 直接复制arguments这个伪数组，让它变成真正的数组，从而拥有数组的方法。
  console.log(arr); //[1, 2, 3, 4]
  arr.push(5);
  console.log(arr); //[1, 2, 3, 4, 5]
}
show(1, 2, 3, 4);
```
浅拷贝：只拷贝了基本类型的数据，而对于引用类型的数据，复制后也是会发生引用。
### 循环拷贝2
```js
var obj1 = {
	name: 'lisi',
	arr: [1, 2, 3]
}
function copy(obj1) {
	var obj2 = {};
	for(let key in obj1) {
		obj2[key] = obj1[key];
	}
	return obj2;
}
var obj2 = copy(obj1);
obj2.arr.push(4);
console.log(obj1.arr); // [1, 2, 3, 4]
console.log(obj2.arr); // [1, 2, 3, 4]
```
## 数组深拷贝
### JSON.parse && JSON.stringify(技巧)
```js
const arr = ['test', {name: 'lisi'}, [1, 2, 3]];
const arr_new = JSON.parse(JSON.stringify(arr));

arr[1].name = 'wangwu';
console.log(arr); // [ 'test', { name: 'wangwu' }, [ 1, 2, 3 ] ]
console.log(arr_new); // [ 'test', { name: 'lisi' }, [ 1, 2, 3 ] ]
```
### 存在的问题-不能拷贝函数
```js
const arr = [
    function() {console.log('a')},
    {
        b: function() {console.log('b')}
    }
];
const arr_new = JSON.parse(JSON.stringify(arr));
console.log(arr_new); // [ null, {} ]
```
## 浅拷贝的实现
concat、slice、JSON.stringify都算是技巧类，可以根据实际项目情况选择使用，接下来我们思考下如何实现一个对象或者数组的浅拷贝。
想一想，好像很简单，遍历对象，然后把属性和属性值都放在一个新的对象不就好了。
嗯，就是这么简单，注意几个小点就可以了：
```js
const shallowClone = obj => {
    // 只拷贝对象
    // typeof [111] === 'object' // true
    if (typeof obj !== 'object') return;
    // 根据obj的类型判断是新建一个数组还是对象
    const new_obj = obj instanceof Array ? [] : {};
    for (let key in obj) {
        console.log(key);
        // 遍历obj，并且判断是obj的属性才拷贝
        if (obj.hasOwnProperty(key)) {
            new_obj[key] = obj[key];
        }
    }
    return new_obj;
};

console.log(shallowClone([{name: 'lisi', age: 22}]));
```
如果数组元素是基本类型，就会拷贝一份，互不影响，而如果是对象或者数组，就会只拷贝对象和数组的引用，这样我们无论在新旧数组进行了修改，两者都会发生变化。

我们把这种复制引用的拷贝方法称之为浅拷贝，与之对应的就是深拷贝，深拷贝就是指完全的拷贝一个对象，即使嵌套了对象，两者也相互分离，修改一个对象的属性，也不会影响另一个。
使用concat和slice是一种浅拷贝。

## 深拷贝
深拷贝采用递归的方式去拷贝对象，来解决浅拷贝的弊端。简而言之，深拷贝是对对象以及对象的所有子对象进行拷贝。
```js
var obj1 = {
	name: 'lisi',
	age: 18,
	job: 'worker',
	arr1: [1, 2, 3, 4, 5],
	arr2:[
        {name: 'wangwu', age: 22, job: 'teacher'},
        {name: 'zhaoliu', age: 22, job: 'student'}
	]};
var obj2 = {};
function deepClone(obj1, obj2) {
	var obj2 = obj2 || {}; // 给obj2一个初始值=它自己或者是一个空对象
	for(let key in obj1) {
		if(typeof obj1[key] === 'object') { // 先判断obj1[key]是否是对象
			obj2[key] = (obj1[key].constructor === Array) ? [] : {};
			copy(obj1[key], obj2[key]); // 循环调用复制函数
		}
		else {
			obj2[key] = obj1[key]; // obj1[key]不是对象则直接复制
		}
	}
	return obj2;
}

obj2 = deepClone(obj1, obj2);
obj2.arr1.push(6);

console.log(obj2.arr1);
console.log(obj1.arr1);
```
### 实现深拷贝
```js
Object.prototype.toString.call([]).slice(8, -1); // "Array"
```
```js
const arr = [4, 5, 6];
// for...in遍历数组的时候遍历的是元素下标
for (let key in arr) {
    console.log(key); // 0 1 2
}
```
```js
function getObjectType(obj) {
    const type = Object.prototype.toString.call(obj).slice(8, -1);
    if (type === 'Null') {
        return 'Null';
    } else if (type === 'Undefined') {
        return 'Undefined';
    } else {
        return type;
    }
}
function deepClone(obj) {
    let res, objType = getObjectType(obj);
    // 先判断obj的类型，只有是引用类型才进行遍历
    if (objType === 'Object') {
        res = {};
    } else if (objType === 'Array') {
        res = [];
    } else {
        // 如果是基本数据数据类型不复制，直接将源数据返回
        return obj;
    }
    // 遍历目标对象
    for (let key in obj) {
        const value = obj[key];
        res[key] = deepClone(value);
    }
    return res;
}

const obj = {
    name: 'lisi',
    age: 12,
    hobbies: ['🏀', '⚽️'],
    other: {
        a: 1,
        b: 2
    }
}
const obj2 = deepClone(obj);
console.log(obj2);
obj2.other.a = 666;
obj.hobbies.push('💰');
console.log(obj);
console.log(obj2);
```
```js
{ name: 'lisi',
  age: 12,
  hobbies: [ '🏀', '⚽️' ],
  other: { a: 1, b: 2 } }
{ name: 'lisi',
  age: 12,
  hobbies: [ '🏀', '⚽️', '💰' ],
  other: { a: 1, b: 2 } }
{ name: 'lisi',
  age: 12,
  hobbies: [ '🏀', '⚽️' ],
  other: { a: 666, b: 2 } }
```
## 引用类型数据深拷贝实现
对象深拷贝需要注意的问题：
1. 属性为函数
2. 属性为null或者undefined
3. 属性为Date
4. 属性为正则
```js
const deepClone = obj => {
    // 只拷贝对象
    if (typeof obj !== 'object') return;
    // 根据obj的类型判断是新建一个数组还是对象
    const new_obj = obj instanceof Array ? [] : {};
    for (let key in obj) {
        console.log(key);
        // 遍历obj，并且判断是obj的属性才拷贝
        if (obj.hasOwnProperty(key)) {
            // 核心部分，判断是对象类型则递归拷贝
            new_obj[key] = typeof obj[key] === 'object' ? deepClone(obj[key]) : obj[key];
        }
    }
    return new_obj;
};

console.log(deepClone([{name: 'lisi', age: 22, hobbies: ['篮球', '足球']}]));
```
```js
// 递归拷贝
// hash = new WeakMap 哈希表解决循环引用问题
// WeakMap 弱引用，不能用Map，会导致内存泄露
function deepClone(value, hash = new WeakMap) {
    // 先把特殊情况全部过滤掉
    // null == undefined // true
    // 排除null和undefined
    if (value == null) { // null和undefined 是不需要拷贝的，直接返回
        return value;
    }
    if (value instanceof RegExp) { // 处理正则
        return new RegExp(value);
    }
    if (value instanceof Date) { // 处理日期
        return new Date(value);
    }
    // 函数是不需要拷贝的
    // 排除不是对象类型，包括函数和基本数据类型
    if (typeof value !== 'object') {
        return value;
    }
    // 根据constructor来区分对象和数组
    let obj = new value.constructor();
    // 说明是一个对象类型
    if (hash.get(value)) { // 有拷贝的就直接返回
        return hash.get(value);
    }
    hash.set(value, obj); // 制作一个映射表，解决循环拷贝问题
    // 区分对象和数组
    for (let key in value) {
        // 不拷贝原型链上的属性
        if (value.hasOwnProperty(key)) {
            // 递归拷贝
            obj[key] = deepClone(value[key], hash);
        }
    }
    return obj;
}
// let obj = {name: 'lisi', age: {num: 10}};
let obj = [[1, 2, 3]];
let obj1 = deepClone(obj);
// obj.age.num = 100;
console.log(obj); // { name: 'lisi', age: { num: 100 } }
// obj1.age.num = 1000;
console.log(obj1); // { name: 'lisi', age: { num: 1000 } }

let o = {};
o.x = o; // 循环引用，死循环了
let o1 = deepClone(o); // 如果这个对象拷贝过了，就返回那个拷贝的结果就可以了
console.log(o1); // RangeError: Maximum call stack size exceeded
// { x: [Circular] }

// 判断类型 typeof instanceof constructor
// Object.prototype.toString.call()
```
```js
// 根据constructor来区分对象和数组
// let obj = new value.constructor();

[1, 2].constructor
ƒ Array() { [native code] }

let obj = {name: 'lisi'}
obj.constructor
ƒ Object() { [native code] }
```
## 总结
所谓的深拷贝和浅拷贝，针对是`Object和Array`这样的引用数据类型。

* 浅拷贝：只拷贝第一层的原始类型值，和第一层的引用类型地址。
* 深拷贝：拷贝所有的属性值，以及属性地址指向的值的内存空间。

通过递归拷贝或者JSON来做深拷贝，都会有一些问题。

需要注意：以下方法都属于浅拷贝。
* 对象的Object.assign()
* 数组的Array.prototype.slice()
* 数组的Array.prototype.concat()
* 数组的Array.from()
* ES6的扩展运算符

## 参考文档
1. [终于弄清楚JS的深拷贝和浅拷贝了](https://blog.csdn.net/weixin_37719279/article/details/81240658)[前端面试题系列9」浅拷贝与深拷贝的含义、区别及实现（文末有岗位内推哦~）](https://segmentfault.com/a/1190000018879536#articleHeader5)
2. [深拷贝的终极探索（90%的人都不知道）](https://juejin.im/post/5bc1ae9be51d450e8b140b0c#heading-3)
3. [JavaScript专题之深浅拷贝](https://juejin.im/post/59658504f265da6c415f3324)
4. [js中对象的复制，浅复制（浅拷贝）和深复制（深拷贝）](https://www.jianshu.com/p/0d7bd31ccf43)
5. [浅谈js中的浅拷贝和深拷贝](https://www.cnblogs.com/MECN/p/6606119.html)
6. [javascript中的深拷贝和浅拷贝？](https://www.zhihu.com/question/23031215)
7. [React 数据为什么要使用immutable方式？浅复制与深复制思考](https://segmentfault.com/a/1190000006729489)
8. [面试官:请你实现一个深克隆](https://juejin.im/post/5abb55ee6fb9a028e33b7e0a)
9. [js浅拷贝与深拷贝方法](https://segmentfault.com/a/1190000016440069#articleHeader7)