---
title: 1. TypeScript数据类型
---
TypeScript是JavaScript的类型的超集，它可以编译成纯JavaScript。编译出来的JavaScript可以运行在任何浏览器上。TypeScript 编译工具可以运行在任何服务器和任何系统上。TypeScript是开源的。

首先声明一点：TypeScript中变量是**强类型**的。TypeScript中为了使编写的代码更加规范，更有利于维护，增加了类型校验，就是在定义变量的时候要指定变量类型。

>TypeScript中的数据类型有：

* undefined
* null: 空类型;
* Number: 数值类型;
* String: 字符串类型;
* Boolean: 布尔类型;
* enum: 枚举类型;
* any: 任意类型;
* void: 空类型；
* Array: 数组类型;
* Tuple: 元祖类型;
* never类型

>ts代码必须指定变量类型。

<img :src="$withBase('/ts/ts_type4.png')" alt="">

## 数组
```ts
// var arr = [1, 2, 3]; // es5定义数组方式

// ts定义数组，方式1
let arr:number[] = [1, 2, 3];
console.log(arr);
// ts定义数组，方式2
let arr:Array<number> = [2, 3, 4];
console.log(arr);
```
## 元组(属于数组的一种)
元组可以给数组中的每个索引元素指定数据类型。
```js
const tuple: [number, string, boolean] = [24, 'abc', true];
```
如果不遵循为元组预设排序的索引规则，那么Typescript会警告：
<img :src="$withBase('/ts/ts_type.png')" alt="">

tuple第一项应为number类型。
## enum(枚举)
```js
enum Flag {
    succuss = 1,
    error = 2,
    undedined = -1,
    null = -2
}
// 指定s和e均为枚举类型
let s:Flag = Flag.succuss;
let e:Flag = Flag.error;
let u:Flag = Flag.undedined;
let n:Flag = Flag.null;
console.log(s, e, u, n); // 1 2 -1 -2
```
```js
// 枚举
// 默认情况从0开始为元素编号，也可手动为1开始
enum Color {Red=1, Green, Blue}
let c:Color = Color.Blue;
console.log(c); // 3
let colorName: string = Color[2];
console.log(colorName); // Green 因为上面代码里它的值是2
```
<img :src="$withBase('/ts/ts_type2.png')" alt="">

## any
```js
// 基本用法
let anytest:any = 123;
anytest = 'test';

console.log(anytest);
```
```js
// any类型的使用场景
const box:any = document.querySelector('.box');
box.style.color = 'red';
```
>在ts中不设置any会报错：

<img :src="$withBase('/ts/ts_type3.png')" alt="">

## null和undefined
null和undefined是其他(never类型)数据类型的子类型
```js
// num2为null、undefined或者数值类型
var num2:number | undefined | null;
num2 = 123;
console.log(num);
```
## void
void类型表示没有任何类型，一般用于定义方法的时候方法没有返回值。
```js
// 表示run方法没有返回值
function run():void {
    console.log(111);
}
// 指定为undefined表示该方法返回undefined
function run():undefined {
    console.log(111);
    return undefined;
}
```
## never
never类型：即其他类型(包括null和unfined)的子类型，代表从不会出现的值。never类型的变量只能被never类型赋值。
```js
let a:undefined;
a = undefined;

let b:null;
b = null;

let c:never;
c = (() => {
    throw new Error('错误');
})();
```
## 类型推论
如果没有明确的指定类型，那么 TypeScript 会依照类型推论（Type Inference）的规则推断出一个类型。

如果定义的时候没有赋值，不管之后有没有赋值，都会被推断成 any 类型而完全不被类型检查。
## 联合类型
联合类型（Union Types）表示取值可以为多种类型中的一种。
```js
let myFavoriteNumber: string | number;
myFavoriteNumber = 'seven';
myFavoriteNumber = 7;
```
```js
let myFavoriteNumber: string | number;
myFavoriteNumber = true;

// index.ts(2,1): error TS2322: Type 'boolean' is not assignable to type 'string | number'.
//   Type 'boolean' is not assignable to type 'number'.
```
联合类型使用 | 分隔每个类型。这里的`let myFavoriteNumber: string | number`的含义是，允许myFavoriteNumber的类型是string或者number，但是不能是其他类型。

### 访问联合类型的属性或方法
当 TypeScript 不确定一个联合类型的变量到底是哪个类型的时候，我们只能访问此联合类型的所有类型里共有的属性或方法：
```js
function getLength(something: string | number): number {
    return something.length;
}

// index.ts(2,22): error TS2339: Property 'length' does not exist on type 'string | number'.
//   Property 'length' does not exist on type 'number'.
```
上例中，length 不是 string 和 number 的共有属性，所以会报错。
访问 string 和 number 的共有属性是没问题的：
```js
function getString(something: string | number): string {
    return something.toString();
}
```
联合类型的变量在被赋值的时候，会根据类型推论的规则推断出一个类型：
```js
let myFavoriteNumber: string | number;
myFavoriteNumber = 'seven';
console.log(myFavoriteNumber.length); // 5
myFavoriteNumber = 7;
console.log(myFavoriteNumber.length); // 编译时报错

// index.ts(5,30): error TS2339: Property 'length' does not exist on type 'number'.
```
上例中，第二行的 myFavoriteNumber 被推断成了 string，访问它的 length 属性不会报错。
而第四行的 myFavoriteNumber 被推断成了 number，访问它的length属性时就报错了。
